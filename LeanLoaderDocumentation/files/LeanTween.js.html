<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>LeanTween.js - LeanLoader</title>
    <link rel="stylesheet" href="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;3.8.0pr2&#x2F;build&#x2F;cssgrids&#x2F;cssgrids-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/css/main.css" id="site_styles">
    <script src="http://ajax.googleapis.com/ajax/libs/jquery/1.8.3/jquery.min.js"></script>
    <script type="text/javascript">
      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-23694672-1']);
      _gaq.push(['_trackPageview']);

      (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();
    </script>
    <script src="..&#x2F;assets/js/leantween.js"></script>
    <link rel="shortcut icon" type="image/png" href="..&#x2F;assets/favicon.png">
    <script src="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;combo?3.8.0pr2&#x2F;build&#x2F;yui&#x2F;yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><a href="http://dentedpixel.com/developer-diary/leantween-speed-comparison-to-itween/"><img src="http:&#x2F;&#x2F;s3.amazonaws.com&#x2F;dentedpixel.com&#x2F;LeanTween&#x2F;leantween-logo.png" title="LeanLoader"></a></h1> <div style="position:absolute; left:146px; top:90px;">- Developed by <a href="http://www.dentedpixel.com">Dented Pixel</a></div>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: LeanLoader 0.2</em><br>
            <form action="https://www.paypal.com/cgi-bin/webscr" method="post">
            <input type="hidden" name="cmd" value="_s-xclick">
            <input type="hidden" name="hosted_button_id" value="YJPUT3RAK5VL8">
            <input type="image" src="https://www.paypalobjects.com/en_US/i/btn/btn_donate_LG.gif" border="0" name="submit" alt="PayPal - The safer, easier way to pay online!">
            <img alt="" border="0" src="https://www.paypalobjects.com/en_US/i/scr/pixel.gif" width="1" height="1">
            </form>

        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="..&#x2F;classes/LeanTween.html">LeanTween</a></li>
            
                <li><a href="..&#x2F;classes/LeanTweenType.html">LeanTweenType</a></li>
            
                <li><a href="..&#x2F;classes/LTBezierPath.html">LTBezierPath</a></li>
            
                <li><a href="..&#x2F;classes/LTRect.html">LTRect</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
            </ul>
        </div>
    </div>
</div>

                <div id="advertising">
                    <h2>Games Developed<br>by<br><a href="http://www.dentedpixel.com">Dented Pixel</a></h2><br>
                    <a href="https://itunes.apple.com/us/app/monkeyshines/id530998075?mt=8" target="_blank"><img src="http://a5.mzstatic.com/us/r1000/102/Purple/v4/00/5c/57/005c571e-ef17-2370-6aad-058a17ff9fd9/mzm.yvphsjfk.175x175-75.jpg" /><br>Monkeyshines - A swinging good time!</a>
                    <br>
                    <a href="https://itunes.apple.com/us/app/princess-piano/id445283531?mt=8" target="_blank"><img src="http://a3.mzstatic.com/us/r1000/096/Purple/v4/8c/1e/05/8c1e0590-db82-1d72-2956-2b6470f37ed0/mza_4230031260893485317.175x175-75.jpg" /><br>Princess Piano - Learn musical notation<br>in this melodious adventure!</a>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: LeanTween.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
&#x2F;&#x2F; Copyright (c) 2013 Russell Savage - Dented Pixel
&#x2F;&#x2F; 
&#x2F;&#x2F; LeanTween version 1.17 - http:&#x2F;&#x2F;dentedpixel.com&#x2F;developer-diary&#x2F;
&#x2F;&#x2F;
&#x2F;&#x2F; Permission is hereby granted, free of charge, to any person obtaining a copy
&#x2F;&#x2F; of this software and associated documentation files (the &quot;Software&quot;), to deal
&#x2F;&#x2F; in the Software without restriction, including without limitation the rights
&#x2F;&#x2F; to use, copy, modify, merge, publish, distribute, sublicense, and&#x2F;or sell
&#x2F;&#x2F; copies of the Software, and to permit persons to whom the Software is
&#x2F;&#x2F; furnished to do so, subject to the following conditions:
&#x2F;&#x2F;
&#x2F;&#x2F; The above copyright notice and this permission notice shall be included in
&#x2F;&#x2F; all copies or substantial portions of the Software.
&#x2F;&#x2F;
&#x2F;&#x2F; THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
&#x2F;&#x2F; IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
&#x2F;&#x2F; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
&#x2F;&#x2F; AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
&#x2F;&#x2F; LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
&#x2F;&#x2F; OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
&#x2F;&#x2F; THE SOFTWARE.

&#x2F;*
TERMS OF USE - EASING EQUATIONS
Open source under the BSD License.
Copyright (c)2001 Robert Penner
All rights reserved.
Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and&#x2F;or other materials provided with the distribution.
Neither the name of the author nor the names of contributors may be used to endorse or promote products derived from this software without specific prior written permission.
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*&#x2F;
#pragma strict 
#pragma downcast


&#x2F;**
* Pass this to the &quot;ease&quot; parameter in the optional hashtable, to get a different easing behavior&lt;br&gt;&lt;br&gt;
* &lt;strong&gt;Example Javascript: &lt;&#x2F;strong&gt;&lt;br&gt;LeanTween.rotateX(gameObject, 270.0f, 1.5f, {&quot;ease&quot;:LeanTweenType.easeInBack});&lt;br&gt;
* &lt;br&gt;
* &lt;strong&gt;Example C#: &lt;&#x2F;strong&gt; &lt;br&gt;
* Hashtable optional = new Hashtable();&lt;br&gt;
* optional.Add(&quot;ease&quot;:LeanTweenType.easeInBack);&lt;br&gt;
* LeanTween.rotateX(gameObject, 270.0f, 1.5f, optional);&lt;br&gt;
*
* @class LeanTweenType
*&#x2F;

&#x2F;**
* @property {integer} linear
*&#x2F;
&#x2F;**
* @property {integer} easeOutQuad
*&#x2F;
&#x2F;**
* @property {integer} easeInQuad
*&#x2F;
&#x2F;**
* @property {integer} easeInOutQuad
*&#x2F;
&#x2F;**
* @property {integer} easeInCubic
*&#x2F;
&#x2F;**
* @property {integer} easeOutCubic
*&#x2F;
&#x2F;**
* @property {integer} easeInOutCubic
*&#x2F;
&#x2F;**
* @property {integer} easeInQuart
*&#x2F;
&#x2F;**
* @property {integer} easeOutQuart
*&#x2F;
&#x2F;**
* @property {integer} easeInOutQuart
*&#x2F;
&#x2F;**
* @property {integer} easeInQuint
*&#x2F;
&#x2F;**
* @property {integer} easeOutQuint
*&#x2F;
&#x2F;**
* @property {integer} easeInOutQuint
*&#x2F;
&#x2F;**
* @property {integer} easeInSine
*&#x2F;
&#x2F;**
* @property {integer} easeOutSine
*&#x2F;
&#x2F;**
* @property {integer} easeInOutSine
*&#x2F;
&#x2F;**
* @property {integer} easeInExpo
*&#x2F;
&#x2F;**
* @property {integer} easeOutExpo
*&#x2F;
&#x2F;**
* @property {integer} easeInOutExpo
*&#x2F;
&#x2F;**
* @property {integer} easeInCirc
*&#x2F;
&#x2F;**
* @property {integer} easeOutCirc
*&#x2F;
&#x2F;**
* @property {integer} easeInOutCirc
*&#x2F;
&#x2F;**
* @property {integer} easeInBounce
*&#x2F;
&#x2F;**
* @property {integer} easeOutBounce
*&#x2F;
&#x2F;**
* @property {integer} easeInOutBounce
*&#x2F;
&#x2F;**
* @property {integer} easeInBack
*&#x2F;
&#x2F;**
* @property {integer} easeOutBack
*&#x2F;
&#x2F;**
* @property {integer} easeInOutBack
*&#x2F;
&#x2F;**
* @property {integer} easeInElastic
*&#x2F;
&#x2F;**
* @property {integer} easeOutElastic
*&#x2F;
&#x2F;**
* @property {integer} easeInOutElastic
*&#x2F;
&#x2F;**
* @property {integer} punch
*&#x2F;
public enum LeanTweenType{
	notUsed, linear, easeOutQuad, easeInQuad, easeInOutQuad, easeInCubic, easeOutCubic, easeInOutCubic, easeInQuart, easeOutQuart, easeInOutQuart, 
	easeInQuint, easeOutQuint, easeInOutQuint, easeInSine, easeOutSine, easeInOutSine, easeInExpo, easeOutExpo, easeInOutExpo, easeInCirc, easeOutCirc, easeInOutCirc, 
	easeInBounce, easeOutBounce, easeInOutBounce, easeInBack, easeOutBack, easeInOutBack, easeInElastic, easeOutElastic, easeInOutElastic, punch, once, clamp, pingPong
}

class LeanTweenDescr{
	var toggle:boolean;
	var trans:Transform;
	var ltRect:LTRect;
	var from:Vector3;
	var to:Vector3;
	var diff:Vector3;
	var path:LTBezierPath;
	var time:float;
	var useEstimatedTime:boolean;
	var useFrames:boolean;
	var passed:float;
	var hasInitialized:boolean;
	var type:TweenAction;
	var optional:Hashtable;
	var delay:float;
	var tweenFunc:Function;
	var easeType:LeanTweenType;
	var animationCurve:AnimationCurve;
	var id:int;
	var loopType:int;
	var loopCount:int;
	var direction:float;
	
	public function ToString(){
		return &quot;gameObject:&quot;+trans.gameObject+&quot; toggle:&quot;+toggle+&quot; passed:&quot;+passed+&quot; time:&quot;+time+&quot; delay:&quot;+delay+&quot; from:&quot;+from+&quot; to:&quot;+to+&quot; type:&quot;+type+&quot; useEstimatedTime:&quot;+useEstimatedTime+&quot; id:&quot;+id+&quot; optional:&quot;+optional;
	}

	public function setDelay( delay:float ):LeanTweenDescr{
		this.delay = delay;
		return this;
	}

	public function setEase( easeType:LeanTweenType ):LeanTweenDescr{
		this.easeType = easeType;
		return this;
	}

	public function setOnComplete( Action ){
		
	}
}

&#x2F;**
* Animate GUI Elements by creating this object and passing the *.rect variable to the GUI method&lt;br&gt;&lt;br&gt;
* &lt;strong&gt;Example Javascript: &lt;&#x2F;strong&gt;&lt;br&gt;var bRect:LTRect = new LTRect( 0, 0, 100, 50 );&lt;br&gt;
* LeanTween.scale( bRect, Vector2(bRect.rect.width, bRect.rect.height) * 1.3, 0.25 );&lt;br&gt;
* function OnGUI(){&lt;br&gt;
* &amp;nbsp; if(GUI.Button(bRect.rect, &quot;Scale&quot;)){ }&lt;br&gt;
* }&lt;br&gt;
* &lt;br&gt;
* &lt;strong&gt;Example C#: &lt;&#x2F;strong&gt; &lt;br&gt;
* LTRect bRect = new LTRect( 0f, 0f, 100f, 50f );&lt;br&gt;
* LeanTween.scale( bRect, new Vector2(150f,75f), 0.25f );&lt;br&gt;
* void OnGUI(){&lt;br&gt;
* &amp;nbsp; if(GUI.Button(bRect.rect, &quot;Scale&quot;)){ }&lt;br&gt;
* }&lt;br&gt;
*
* @class LTRect
* @constructor
* @param {float} x:float X location
* @param {float} y:float Y location
* @param {float} width:float Width
* @param {float} height:float Height
* @param {float} (alpha:float) Alpha (optional parameter, in case you are using the alpha functions and wish to start at an alpha different than 1.0)
* @param {float} (rotation:float) Rotation (optional parameter, in case you are using the rotate function and wish to start at a rotation different than 0.0)
*&#x2F;

class LTRect{
	&#x2F;**
	* Pass this value to the GUI Methods
	* 
	* @property rect
	* @type {Rect} rect:Rect Rect object that controls the positioning and size
	*&#x2F;
	public var _rect:Rect;
	public var alpha:float;
	public var rotation:float;
	public var pivot:Vector2;

	public var rotateEnabled:boolean;
	public var rotateFinished:boolean;
	public var alphaEnabled:boolean;

	public function LTRect(x:float, y:float, width:float, height:float){
		_rect = Rect(x,y,width,height);
		this.alpha = 1.0;
		this.rotation = 0.0;
		this.rotateEnabled = this.alphaEnabled = false;
	}

	public function LTRect(x:float, y:float, width:float, height:float, alpha:float){
		_rect = Rect(x,y,width,height);
		this.alpha = alpha;
		this.rotation = 0.0;
		this.rotateEnabled = this.alphaEnabled = false;
	}

	public function LTRect(x:float, y:float, width:float, height:float, alpha:float, rotation:float){
		_rect = Rect(x,y,width,height);
		this.alpha = alpha;
		this.rotation = rotation;
		this.rotateEnabled = this.alphaEnabled = false;
		if(rotation!=0.0){
			this.rotateEnabled = true;
			resetForRotation();
		}
	}

	function resetForRotation(){
		if(pivot==Vector2.zero){
			pivot = Vector2(_rect.x+_rect.width*0.5, _rect.y+_rect.height*0.5);
			_rect.x += -pivot.x;
			_rect.y += -pivot.y;
		}
	}

	function get rect():Rect{
		if(rotateEnabled){
			if(rotateFinished){
				rotateFinished = false;
				rotateEnabled = false;
				_rect.x += pivot.x;
				_rect.y += pivot.y;
				pivot = Vector2.zero;
				GUI.matrix = Matrix4x4.identity; 
			}else{
				var trsMatrix:Matrix4x4 = Matrix4x4.identity; 
				trsMatrix.SetTRS(pivot, Quaternion.Euler(0,0,rotation), Vector3.one);
				GUI.matrix = trsMatrix;
			}
		}else if(alphaEnabled){
			GUI.color.a = alpha;
		}
		return _rect;
	}

	function set rect( value ){
		_rect = value;
	}
}

class LTBezier{
	public var length:float;

	private var a:Vector3;
	private var aa:Vector3;
	private var bb:Vector3;
	private var cc:Vector3;
	private var len:float;
	private var arcLengths:float[];

	public function LTBezier(a:Vector3, b:Vector3, c:Vector3, d:Vector3, precision:float){
		this.a = a;
	    aa = (-a + 3*(b-c) + d);
	    bb = 3*(a+c) - 6*b;
	    cc = 3*(b-a);

	    this.len = 1.0 &#x2F; precision;
	    arcLengths = new float[this.len + 1];
	    arcLengths[0] = 0;

	    var ov:Vector3 = a;
	    var v:Vector3;
	    var clen:float = 0.0;
	    for(var i:int = 1; i &lt;= this.len; i++) {
	        v = bezierPoint(i * precision);
	        clen += (ov - v).magnitude;
	        this.arcLengths[i] = clen;
	        ov = v;
	    }
	    this.length = clen;
	}

    private function map(u:float):float {
        var targetLength:float = u * this.arcLengths[this.len];
        var low:int = 0;
        var high:int = this.len;
        var index:int = 0;
        while (low &lt; high) {
            index = low + (((high - low) &#x2F; 2) | 0);
            if (this.arcLengths[index] &lt; targetLength) {
                low = index + 1;
            } else {
                high = index;
            }
        }
        if(this.arcLengths[index] &gt; targetLength)
            index--;
        if(index&lt;0)
        	index = 0;

        return (index + (targetLength - arcLengths[index]) &#x2F; (arcLengths[index + 1] - arcLengths[index])) &#x2F; this.len;
    }

   	private function bezierPoint(t:float):Vector3{
	    return ((aa* t + (bb))* t + cc)* t + a;
	}

    public function point(t:float):Vector3{ 
    	return bezierPoint( map(t) ); 
    }
}

&#x2F;**
* Manually animate along a bezier path with this class
* @class LTBezierPath
* @constructor
* @param {float} pts:Vector3[] A set of points that define one or many bezier paths (the paths should be passed in multiples of 4, which correspond to each individual bezier curve)
*&#x2F;
class LTBezierPath{
	public var pts:Vector3[];
	public var length:float;
	public var orientToPath:boolean;

	private var beziers:LTBezier[];
	private var lengthRatio:float[];
	
	public function LTBezierPath( pts_:Vector3[] ){
		pts = pts_;
		
		var k:int = 0;
		beziers = new LTBezier[ pts.Length &#x2F; 4 ];
		lengthRatio = new float[ beziers.Length ];
		for(var i:int=0; i &lt; pts.Length; i+=4){
			beziers[k] = new LTBezier(pts[i+0],pts[i+2],pts[i+1],pts[i+3],0.05);
			length += beziers[k].length;
			k++;
		}
		&#x2F;&#x2F; Debug.Log(&quot;beziers.Length:&quot;+beziers.Length + &quot; beziers:&quot;+beziers);
		for(i = 0; i &lt; beziers.Length; i++){
			lengthRatio[i] = beziers[i].length &#x2F; length;
		}
	}

	public function point( ratio:float ):Vector3{
		var added:float = 0.0;
		for(var i:int = 0; i &lt; lengthRatio.Length; i++){
			added += lengthRatio[i];
			if(added &gt;= ratio)
				return beziers[i].point( (ratio-(added-lengthRatio[i])) &#x2F; lengthRatio[i] );
		}
		return beziers[lengthRatio.Length-1].point( 1.0 );;
	}

	public function place( transform:Transform, ratio:float ){
		place( transform, ratio, Vector3.up );
	}

	public function place( transform:Transform, ratio:float, worldUp:Vector3 ){
		transform.position = point( ratio );
		ratio += 0.001;
		if(ratio&lt;=1.0)
			transform.LookAt( point( ratio ), worldUp );
	}

	public function placeLocal( transform:Transform, ratio:float ){
		placeLocal( transform, ratio, Vector3.up );
	}

	public function placeLocal( transform:Transform, ratio:float, worldUp:Vector3 ){
		transform.localPosition = point( ratio );
		ratio += 0.001;
		if(ratio&lt;=1.0)
			transform.LookAt( transform.parent.TransformPoint( point( ratio ) ), worldUp );
	}
}

private enum TweenAction{
	MOVE_X,
	MOVE_Y,
	MOVE_Z,
	MOVE_LOCAL_X,
	MOVE_LOCAL_Y,
	MOVE_LOCAL_Z,
	MOVE_CURVED,
	MOVE_CURVED_LOCAL,
	SCALE_X,
	SCALE_Y,
	SCALE_Z,
	ROTATE_X,
	ROTATE_Y,
	ROTATE_Z,
	ROTATE_AROUND,
	ALPHA,
	ALPHA_VERTEX,
	CALLBACK,
	MOVE,
	MOVE_LOCAL,
	ROTATE,
	ROTATE_LOCAL,
	SCALE,
	VALUE3,
	GUI_MOVE,
	GUI_SCALE,
	GUI_ALPHA,
	GUI_ROTATE
}

&#x2F;**
* LeanTween is an efficient tweening engine for Unity3d&lt;br&gt;&lt;br&gt;
* &lt;strong id=&#x27;optional&#x27;&gt;Optional Parameters&lt;&#x2F;strong&gt; are passed in a hash table variable that is accepted at the end of every tweening function.&lt;br&gt;
* Values you can pass:&lt;br&gt;
* &lt;strong&gt;delay&lt;&#x2F;strong&gt;: time (or frames if you are using &quot;useFrames&quot;) before the tween starts&lt;br&gt;
* &lt;strong&gt;ease&lt;&#x2F;strong&gt;: Function that desribes the easing you want to be used, you can pass your own or use many of the included tweens. ex: &lt;i&gt;{&quot;ease&quot;:LeanTween.easeOutQuad}&lt;&#x2F;i&gt;&lt;br&gt; 
* &lt;strong&gt;onComplete&lt;&#x2F;strong&gt;: Function to call at the end of the tween ex: &lt;i&gt;{&quot;onComplete&quot;:functionToCallOnComplete}&lt;&#x2F;i&gt; or &lt;i&gt;{&quot;onComplete&quot;:functionToCallOnComplete,&quot;onCompleteParam&quot;:hashTableToPassToOnComplete}&lt;&#x2F;i&gt;&lt;br&gt;
* &lt;strong&gt;onUpdate&lt;&#x2F;strong&gt;: Function to call on every update ex: &lt;i&gt;{&quot;onUpdate&quot;:functionToCallOnUpdate}&lt;&#x2F;i&gt; or &lt;i&gt;{&quot;onUpdate&quot;:functionToCallOnUpdate,&quot;onUpdateParam&quot;:hashTableToPassToOnUpdate}&lt;&#x2F;i&gt;&lt;br&gt;
* &lt;strong&gt;useEstimatedTime&lt;&#x2F;strong&gt;: This is useful if the Time.timeScale is set to zero (such as when the game is paused) or some other value and you still want the tween to move at a normal pace ex: &lt;i&gt;{&quot;useEstimatedTime&quot;:true}&lt;&#x2F;i&gt;&lt;br&gt;
* &lt;strong&gt;useFrames&lt;&#x2F;strong&gt;: Instead of time passed for both the delay and time value, the amount of frames that have passed is used &lt;i&gt;ex: {&quot;useFrames&quot;:true}&lt;&#x2F;i&gt;&lt;br&gt;
* &lt;strong&gt;onCompleteTarget&lt;&#x2F;strong&gt;: In C# if you are passing a String to the &quot;onComplete&quot; parameter, this variable allows you to define target to call the function than the game object you are tweening.&lt;br&gt;
* &lt;strong&gt;onUpdateTarget&lt;&#x2F;strong&gt;: The same as onCompleteTarget, but for the onUpdate function.&lt;br&gt;
* &lt;strong&gt;orientToPath&lt;&#x2F;strong&gt;: When moving objects along a bezier curve, this controls whether the object aligns itself with the curve or not
* &lt;strong&gt;repeat&lt;&#x2F;strong&gt;: If you wish the loop to repeat set this value to something other than 1
* &lt;strong&gt;loopType&lt;&#x2F;strong&gt;: If the loop is repeating you can change how it repeats (clamp by default) set this value to ping-pong: &lt;i&gt;ex: {&quot;repeat&quot;:2,&quot;loopType&quot;:LeanTweenType.pingPong}&lt;&#x2F;i&gt;&lt;br&gt;
*
* @class LeanTween
*&#x2F;

public class LeanTween extends MonoBehaviour {

public static var throwErrors:boolean = true;
private static var tweens:LeanTweenDescr[];
private static var tweenMaxSearch:int = 0;
private static var maxTweens:int = 400;
private static var frameRendered:int = -1;
private static var tweenEmpty:GameObject;
private static var dtEstimated:float;
private static var dt:float;
private static var dtActual:float;
private static var tween:LeanTweenDescr;
private static var i:int;
private static var j:int;
private static var k:int;
private static var punch:AnimationCurve = new AnimationCurve( Keyframe(0, 0 ), Keyframe(0.112586, 0.9976035 ), Keyframe(0.3120486, -0.1720615 ), Keyframe(0.4316337, 0.07030682 ), Keyframe(0.5524869, -0.03141804 ), Keyframe(0.6549395, 0.003909959 ), Keyframe(0.770987, -0.009817753 ), Keyframe(0.8838775, 0.001939224 ), Keyframe(1, 0 ) );
private static var emptyHash:Hashtable = new Hashtable();

public static function init(){
	init(maxTweens);
}

&#x2F;**
* This line is optional. Here you can specify the maximum number of tweens you will use (the default is 400).  This must be called before any use of LeanTween is made for it to be effective.
* 
* @method LeanTween.init
* @param {integer} maxSimultaneousTweens:int The maximum number of tweens you will use, make sure you don&#x27;t go over this limit, otherwise the code will throw an error
* @example
*   LeanTween.init( 800 );
*&#x2F;
public static function init(maxSimultaneousTweens:int){
	if(!tweens){
		maxTweens = maxSimultaneousTweens;
		tweenEmpty = GameObject.Find(&quot;~LeanTween&quot;);
		&#x2F;&#x2F; print(&quot;tweenEmpty:&quot;+(tweenEmpty==null));
		if(tweenEmpty==null)
			tweenEmpty = new GameObject();
		tweenEmpty.name = &quot;~LeanTween&quot;;
		tweenEmpty.AddComponent(LeanTween);
		tweenEmpty.isStatic = true;
		tweenEmpty.DontDestroyOnLoad( tweenEmpty );
		&#x2F;&#x2F; tweenEmpty.hideFlags = HideFlags.DontSave;
		
		tweens = new LeanTweenDescr[maxTweens];
		for(i = 0; i &lt; maxTweens; i++){
			tweens[i] = new LeanTweenDescr();
		}
	}
}

public static function reset(){
	tweens = null;
}

public function Update(){
	LeanTween.update();
}

private static var trans:Transform;
private static var mesh:Mesh;
private static var vertices:Vector3[];
private static var colors:Color32[];
private static var timeTotal:float;
private static var tweenAction:int;
private static var optionalItems:Hashtable;
private static var tweenFunc:Function;
private static var animationCurve:AnimationCurve;
private static var ratioPassed:float;
private static var val:float;
private static var fromVect:Vector3;
private static var toVect:Vector3;
private static var newVect:Vector3;
private static var isTweenFinished:boolean;
private static var target:GameObject;
private static var customTarget:GameObject;
private static var onUpdateS:String;
private static var onUpdateF:Function;

private static function update() {
	if(frameRendered != Time.frameCount){ &#x2F;&#x2F; make sure update is only called once per frame
		init();
		dtEstimated = Application.targetFrameRate &gt; 0 ? 1.0 &#x2F; Application.targetFrameRate : 1.0 &#x2F; 60.0;
		dtActual = Time.deltaTime*Time.timeScale;
		&#x2F;&#x2F; if(tweenMaxSearch&gt;1500)
		&#x2F;&#x2F; 	Debug.Log(&quot;tweenMaxSearch:&quot;+tweenMaxSearch +&quot; maxTweens:&quot;+maxTweens);
		for(i = 0; i &lt; tweenMaxSearch &amp;&amp; i &lt; maxTweens; i++){
			
			&#x2F;&#x2F;Debug.Log(&quot;tweens[&quot;+i+&quot;].toggle:&quot;+tweens[i].toggle);
			if(tweens[i].toggle){
				tween = tweens[i];
				trans = tween.trans as Transform;
				timeTotal = tween.time;
				tweenAction = tween.type;
				tweenFunc = tween.tweenFunc;
				animationCurve = tween.animationCurve;
				optionalItems = tween.optional;
				&#x2F;&#x2F;Debug.Log(&quot;type:&quot;+tweens[i].type+&quot; animationCurve:&quot;+animationCurve);
				dt = dtActual;
				if( tween.useEstimatedTime ){
					dt = dtEstimated;
				}else if( tween.useFrames ){
					dt = 1;
				}
				&#x2F;&#x2F;Debug.Log(&quot;tweens[&quot;+i+&quot;]:&quot;+tweens[i] + &quot; dt:&quot;+Time.deltaTime);
				
				if(trans==null){
					removeTween(i);
					continue;
				}
				
				&#x2F;&#x2F; Check for tween finished
				isTweenFinished = false;
				if((tween.passed + dt &gt; timeTotal &amp;&amp; tween.direction &gt; 0.0 )){
					isTweenFinished = true;
					tween.passed = timeTotal; &#x2F;&#x2F; Set to the exact end time so that it can finish tween exactly on the end value
				}else if(tween.direction&lt;0.0 &amp;&amp; tween.passed - dt &lt; 0.0){
					isTweenFinished = true;
					tween.passed = Mathf.Epsilon;
				}
				
				if((tween.passed==0.0 &amp;&amp; tweens[i].delay==0.0) || (tween.passed&gt;0.0 &amp;&amp; !tween.hasInitialized)){
					tween.hasInitialized = true;
					&#x2F;&#x2F; Initialize From Values
					switch(tweenAction){
						case TweenAction.MOVE:
							tween.from = trans.position; break;
						case TweenAction.MOVE_X:
							tween.from.x = trans.position.x; break;
						case TweenAction.MOVE_Y:
							tween.from.x = trans.position.y; break;
						case TweenAction.MOVE_Z:
							tween.from.x = trans.position.z; break;
						case TweenAction.MOVE_LOCAL_X:
							tweens[i].from.x = trans.localPosition.x; break;
						case TweenAction.MOVE_LOCAL_Y:
							tweens[i].from.x = trans.localPosition.y; break;
						case TweenAction.MOVE_LOCAL_Z:
							tweens[i].from.x = trans.localPosition.z; break;
						case TweenAction.SCALE_X:
							tween.from.x = trans.localScale.x; break;
						case TweenAction.SCALE_Y:
							tween.from.x = trans.localScale.y; break;
						case TweenAction.SCALE_Z:
							tween.from.x = trans.localScale.z; break;
						case TweenAction.ALPHA:
							tween.from.x = trans.gameObject.renderer.material.color.a; break;
						case TweenAction.ALPHA_VERTEX:
							tween.from.x = trans.GetComponent(MeshFilter).mesh.colors32[0].a;
							break;
						case TweenAction.MOVE_LOCAL:
							tween.from = trans.localPosition; break;
						case TweenAction.MOVE_CURVED:
							&#x2F;&#x2F; tween.path.pts[0] = trans.position;
							tween.from.x = 0; break;
						case TweenAction.MOVE_CURVED_LOCAL:
							&#x2F;&#x2F; tween.path.pts[0] = trans.localPosition;
							tween.from.x = 0; break;
						case TweenAction.ROTATE:
							tween.from = trans.eulerAngles; 
							tween.to.x = LeanTween.closestRot( tween.from.x, tween.to.x);
							tween.to.y = LeanTween.closestRot( tween.from.y, tween.to.y);
							tween.to.z = LeanTween.closestRot( tween.from.z, tween.to.z);
							break;
						case TweenAction.ROTATE_X:
							tween.from.x = trans.eulerAngles.x; 
							tween.to.x = LeanTween.closestRot( tween.from.x, tween.to.x);
							break;
						case TweenAction.ROTATE_Y:
							tween.from.x = trans.eulerAngles.y; 
							tween.to.x = LeanTween.closestRot( tween.from.x, tween.to.x);
							break;
						case TweenAction.ROTATE_Z:
							tween.from.x = trans.eulerAngles.z; 
							tween.to.x = LeanTween.closestRot( tween.from.x, tween.to.x);
							break;
						case TweenAction.ROTATE_LOCAL:
							tween.from = trans.localEulerAngles; 
							tween.to.x = LeanTween.closestRot( tween.from.x, tween.to.x);
							tween.to.y = LeanTween.closestRot( tween.from.y, tween.to.y);
							tween.to.z = LeanTween.closestRot( tween.from.z, tween.to.z);
							break;
						case TweenAction.ROTATE_AROUND:
							tween.optional[&quot;last&quot;] = 0.0;
							tween.optional[&quot;origRotation&quot;] = trans.eulerAngles;
							break;
						case TweenAction.SCALE:
							tween.from = trans.localScale; break;
						case TweenAction.GUI_MOVE:
							tween.from = Vector3(tween.ltRect.rect.x, tween.ltRect.rect.y, 0.0); break;
						case TweenAction.GUI_SCALE:
							tween.from = Vector3(tween.ltRect.rect.width, tween.ltRect.rect.height, 0.0); break;
						case TweenAction.GUI_ALPHA:
							tween.from.x = tween.ltRect.alpha; break;
						case TweenAction.GUI_ROTATE:
							if(tween.ltRect.rotateEnabled==false){
								tween.ltRect.rotateEnabled = true;
								tween.ltRect.resetForRotation();
							}
							
							tween.from.x = tween.ltRect.rotation; break;
					}
					tween.diff.x = tween.to.x - tween.from.x;
					tween.diff.y = tween.to.y - tween.from.y;
					tween.diff.z = tween.to.z - tween.from.z;
				}
				if(tween.delay&lt;=0){
					&#x2F;&#x2F; Move Values
					ratioPassed = tween.passed &#x2F; timeTotal;
					if(ratioPassed&gt;1.0)
						ratioPassed = 1.0;
					
					if(tweenAction&gt;=TweenAction.MOVE_X &amp;&amp; tweenAction&lt;=TweenAction.CALLBACK){ &#x2F;&#x2F; is a tween variety that only acts on one variable
						if(animationCurve!=null){
							val = tweenOnCurve(tween, ratioPassed);
						}else {
							switch( tween.easeType ){
								case LeanTweenType.linear:
									val = tween.from.x + tween.diff.x * ratioPassed; break;
								case LeanTweenType.easeOutQuad:
									val = easeOutQuadOpt(tween.from.x, tween.diff.x, ratioPassed); break;
								case LeanTweenType.easeInQuad:
									val = easeInQuadOpt(tween.from.x, tween.diff.x, ratioPassed); break;
								case LeanTweenType.easeInOutQuad:
									val = easeInOutQuadOpt(tween.from.x, tween.diff.x, ratioPassed); break;
								case LeanTweenType.easeInCubic:
									val = easeInCubic(tween.from.x, tween.to.x, ratioPassed); break;
								case LeanTweenType.easeOutCubic:
									val = easeOutCubic(tween.from.x, tween.to.x, ratioPassed); break;
								case LeanTweenType.easeInOutCubic:
									val = easeInOutCubic(tween.from.x, tween.to.x, ratioPassed); break;
								case LeanTweenType.easeInQuart:
									val = easeInQuart(tween.from.x, tween.to.x, ratioPassed); break;
								case LeanTweenType.easeOutQuart:
									val = easeOutQuart(tween.from.x, tween.to.x, ratioPassed); break;
								case LeanTweenType.easeInOutQuart:
									val = easeInOutQuart(tween.from.x, tween.to.x, ratioPassed); break;
								case LeanTweenType.easeInQuint:
									val = easeInQuint(tween.from.x, tween.to.x, ratioPassed); break;
								case LeanTweenType.easeOutQuint:
									val = easeOutQuint(tween.from.x, tween.to.x, ratioPassed); break;
								case LeanTweenType.easeInOutQuint:
									val = easeInOutQuint(tween.from.x, tween.to.x, ratioPassed); break;
								case LeanTweenType.easeInSine:
									val = easeInSine(tween.from.x, tween.to.x, ratioPassed); break;
								case LeanTweenType.easeOutSine:
									val = easeOutSine(tween.from.x, tween.to.x, ratioPassed); break;
								case LeanTweenType.easeInOutSine:
									val = easeInOutSine(tween.from.x, tween.to.x, ratioPassed); break;
								case LeanTweenType.easeInExpo:
									val = easeInExpo(tween.from.x, tween.to.x, ratioPassed); break;
								case LeanTweenType.easeOutExpo:
									val = easeOutExpo(tween.from.x, tween.to.x, ratioPassed); break;
								case LeanTweenType.easeInOutExpo:
									val = easeInOutExpo(tween.from.x, tween.to.x, ratioPassed); break;
								case LeanTweenType.easeInCirc:
									val = easeInCirc(tween.from.x, tween.to.x, ratioPassed); break;
								case LeanTweenType.easeOutCirc:
									val = easeOutCirc(tween.from.x, tween.to.x, ratioPassed); break;
								case LeanTweenType.easeInOutCirc:
									val = easeInOutCirc(tween.from.x, tween.to.x, ratioPassed); break;
								case LeanTweenType.easeInBounce:
									val = easeInBounce(tween.from.x, tween.to.x, ratioPassed); break;
								case LeanTweenType.easeOutBounce:
									val = easeOutBounce(tween.from.x, tween.to.x, ratioPassed); break;
								case LeanTweenType.easeInOutBounce:
									val = easeInOutBounce(tween.from.x, tween.to.x, ratioPassed); break;
								case LeanTweenType.easeInBack:
									val = easeInBack(tween.from.x, tween.to.x, ratioPassed); break;
								case LeanTweenType.easeOutBack:
									val = easeOutBack(tween.from.x, tween.to.x, ratioPassed); break;
								case LeanTweenType.easeInOutBack:
									val = easeInOutElastic(tween.from.x, tween.to.x, ratioPassed); break;
								case LeanTweenType.easeInElastic:
									val = easeInElastic(tween.from.x, tween.to.x, ratioPassed); break;
								case LeanTweenType.easeOutElastic:
									val = easeOutElastic(tween.from.x, tween.to.x, ratioPassed); break;
								case LeanTweenType.easeInOutElastic:
									val = easeInOutElastic(tween.from.x, tween.to.x, ratioPassed); break;
								case LeanTweenType.punch:
									tween.animationCurve = LeanTween.punch;
									tween.to.x = tween.from.x + tween.to.x;
									val = tweenOnCurve(tween, ratioPassed); break;
								default:
									val = tweenFunc(tween.from.x, tween.to.x, ratioPassed);								
							}
						
						}
						&#x2F;&#x2F; Debug.Log(&quot;from:&quot;+tween.from.x+&quot; to:&quot;+tween.to.x+&quot; val:&quot;+val+&quot; ratioPassed:&quot;+ratioPassed);
						if(tweenAction==TweenAction.MOVE_X){
							trans.position.x = val;
						}else if(tweenAction==TweenAction.MOVE_Y){
							trans.position.y = val;
						}else if(tweenAction==TweenAction.MOVE_Z){
							trans.position.z = val;
						}if(tweenAction==TweenAction.MOVE_LOCAL_X){
							trans.localPosition.x = val;
						}else if(tweenAction==TweenAction.MOVE_LOCAL_Y){
							trans.localPosition.y = val;
						}else if(tweenAction==TweenAction.MOVE_LOCAL_Z){
							trans.localPosition.z = val;
						}else if(tweenAction==TweenAction.MOVE_CURVED){
							if(tween.path.orientToPath){
								tween.path.place( trans, val );
							}else{
								trans.position = tween.path.point( val );
							}
							&#x2F;&#x2F; Debug.Log(&quot;val:&quot;+val+&quot; trans.position:&quot;+trans.position + &quot; 0:&quot;+ tween.curves[0] +&quot; 1:&quot;+tween.curves[1] +&quot; 2:&quot;+tween.curves[2] +&quot; 3:&quot;+tween.curves[3]);
						}else if(tweenAction==TweenAction.MOVE_CURVED_LOCAL){
							if(tween.path.orientToPath){
								tween.path.placeLocal( trans, val );
							}else{
								trans.localPosition = tween.path.point( val );
							}
							&#x2F;&#x2F; Debug.Log(&quot;val:&quot;+val+&quot; trans.position:&quot;+trans.position);
						}else if(tweenAction==TweenAction.SCALE_X){
							trans.localScale.x = val;
						}else if(tweenAction==TweenAction.SCALE_Y){
							trans.localScale.y = val;
						}else if(tweenAction==TweenAction.SCALE_Z){
							trans.localScale.z = val;
						}else if(tweenAction==TweenAction.ROTATE_X){
					    	trans.eulerAngles.x = val;
					    }else if(tweenAction==TweenAction.ROTATE_Y){
					    	trans.eulerAngles.y = val;
					    }else if(tweenAction==TweenAction.ROTATE_Z){
					    	trans.eulerAngles.z = val;
					    }else if(tweenAction==TweenAction.ROTATE_AROUND){
					    	var last:float = tween.optional[&quot;last&quot;];
					    	var move:float = val - last;
					    	&#x2F;&#x2F; Debug.Log(&quot;move:&quot;+move+&quot; val:&quot;+val + &quot; timeTotal:&quot;+timeTotal + &quot; from:&quot;+tween.from+ &quot; diff:&quot;+tween.diff);
					    	if(isTweenFinished){
					    		var origRotation:Vector3 = tween.optional[&quot;origRotation&quot;];
					    		trans.eulerAngles = origRotation;
					    		trans.RotateAround(trans.TransformPoint( tween.optional[&quot;point&quot;] ), tween.optional[&quot;axis&quot;], tween.to.x);
					    	}else{
					    		trans.RotateAround(trans.TransformPoint( tween.optional[&quot;point&quot;] ), tween.optional[&quot;axis&quot;], move &#x2F;*tween.to.x * (dt&#x2F;timeTotal)*&#x2F;);
					    		tween.optional[&quot;last&quot;] = val;
					    	}
					    }else if(tweenAction==TweenAction.ALPHA){
							for (k = 0; k &lt; trans.gameObject.renderer.materials.Length; k++) {
						        trans.gameObject.renderer.materials[k].color.a = val;
						    }
						}else if(tweenAction==TweenAction.ALPHA_VERTEX){
							mesh = trans.GetComponent(MeshFilter).mesh;
							vertices = mesh.vertices;
							colors = new Color32[vertices.Length];
							var c:Color32 = mesh.colors32[0];
							c.a = val;
							for (k= 0; k &lt; vertices.Length; k++) {
								colors[k] = c;
							}
							mesh.colors32 = colors;
						}
						
					}else if(tweenAction&gt;=TweenAction.MOVE){ &#x2F;&#x2F; is a tween variety that acts on multiple variables
						&#x2F;&#x2F;
						
						if(animationCurve!=null){
							newVect = tweenOnCurveVector(tween, ratioPassed);
						}else{
							if(tween.easeType == LeanTweenType.linear){
								newVect.x = tween.from.x + tween.diff.x * ratioPassed;
								newVect.y = tween.from.y + tween.diff.y * ratioPassed;
								newVect.z = tween.from.z + tween.diff.z * ratioPassed;
							}else if(tween.easeType &gt;= LeanTweenType.linear){
								switch(tween.easeType){
									case LeanTweenType.easeOutQuad:
										newVect.x = easeOutQuadOpt(tween.from.x, tween.diff.x, ratioPassed);
										newVect.y = easeOutQuadOpt(tween.from.y, tween.diff.y, ratioPassed);
										newVect.z = easeOutQuadOpt(tween.from.z, tween.diff.z, ratioPassed); 
										break;
									case LeanTweenType.easeInQuad:
										newVect = Vector3(easeInQuadOpt(tween.from.x, tween.diff.x, ratioPassed), easeInQuadOpt(tween.from.y, tween.diff.y, ratioPassed), easeInQuadOpt(tween.from.z, tween.diff.z, ratioPassed)); break;
									case LeanTweenType.easeInOutQuad:
										newVect = Vector3(easeInOutQuadOpt(tween.from.x, tween.diff.x, ratioPassed), easeInOutQuadOpt(tween.from.y, tween.diff.y, ratioPassed), easeInOutQuadOpt(tween.from.z, tween.diff.z, ratioPassed)); break;
									case LeanTweenType.easeInCubic:
										newVect = Vector3(easeInCubic(tween.from.x, tween.to.x, ratioPassed), easeInCubic(tween.from.y, tween.to.y, ratioPassed), easeInCubic(tween.from.z, tween.to.z, ratioPassed)); break;
									case LeanTweenType.easeOutCubic:
										newVect = Vector3(easeOutCubic(tween.from.x, tween.to.x, ratioPassed), easeOutCubic(tween.from.y, tween.to.y, ratioPassed), easeOutCubic(tween.from.z, tween.to.z, ratioPassed)); break;
									case LeanTweenType.easeInOutCubic:
										newVect = Vector3(easeInOutCubic(tween.from.x, tween.to.x, ratioPassed), easeInOutCubic(tween.from.y, tween.to.y, ratioPassed), easeInOutCubic(tween.from.z, tween.to.z, ratioPassed)); break;
									case LeanTweenType.easeInQuart:
										newVect = Vector3(easeInQuart(tween.from.x, tween.to.x, ratioPassed), easeInQuart(tween.from.y, tween.to.y, ratioPassed), easeInQuart(tween.from.z, tween.to.z, ratioPassed)); break;
									case LeanTweenType.easeOutQuart:
										newVect = Vector3(easeOutQuart(tween.from.x, tween.to.x, ratioPassed), easeOutQuart(tween.from.y, tween.to.y, ratioPassed), easeOutQuart(tween.from.z, tween.to.z, ratioPassed)); break;
									case LeanTweenType.easeInOutQuart:
										newVect = Vector3(easeInOutQuart(tween.from.x, tween.to.x, ratioPassed), easeInOutQuart(tween.from.y, tween.to.y, ratioPassed), easeInOutQuart(tween.from.z, tween.to.z, ratioPassed)); break;
									case LeanTweenType.easeInQuint:
										newVect = Vector3(easeInQuint(tween.from.x, tween.to.x, ratioPassed), easeInQuint(tween.from.y, tween.to.y, ratioPassed), easeInQuint(tween.from.z, tween.to.z, ratioPassed)); break;
									case LeanTweenType.easeOutQuint:
										newVect = Vector3(easeOutQuint(tween.from.x, tween.to.x, ratioPassed), easeOutQuint(tween.from.y, tween.to.y, ratioPassed), easeOutQuint(tween.from.z, tween.to.z, ratioPassed)); break;
									case LeanTweenType.easeInOutQuint:
										newVect = Vector3(easeInOutQuint(tween.from.x, tween.to.x, ratioPassed), easeInOutQuint(tween.from.y, tween.to.y, ratioPassed), easeInOutQuint(tween.from.z, tween.to.z, ratioPassed)); break;
									case LeanTweenType.easeInSine:
										newVect = Vector3(easeInSine(tween.from.x, tween.to.x, ratioPassed), easeInSine(tween.from.y, tween.to.y, ratioPassed), easeInSine(tween.from.z, tween.to.z, ratioPassed)); break;
									case LeanTweenType.easeOutSine:
										newVect = Vector3(easeOutSine(tween.from.x, tween.to.x, ratioPassed), easeOutSine(tween.from.y, tween.to.y, ratioPassed), easeOutSine(tween.from.z, tween.to.z, ratioPassed)); break;
									case LeanTweenType.easeInOutSine:
										newVect = Vector3(easeInOutSine(tween.from.x, tween.to.x, ratioPassed), easeInOutSine(tween.from.y, tween.to.y, ratioPassed), easeInOutSine(tween.from.z, tween.to.z, ratioPassed)); break;
									case LeanTweenType.easeInExpo:
										newVect = Vector3(easeInExpo(tween.from.x, tween.to.x, ratioPassed), easeInExpo(tween.from.y, tween.to.y, ratioPassed), easeInExpo(tween.from.z, tween.to.z, ratioPassed)); break;
									case LeanTweenType.easeOutExpo:
										newVect = Vector3(easeOutExpo(tween.from.x, tween.to.x, ratioPassed), easeOutExpo(tween.from.y, tween.to.y, ratioPassed), easeOutExpo(tween.from.z, tween.to.z, ratioPassed)); break;
									case LeanTweenType.easeInOutExpo:
										newVect = Vector3(easeInOutExpo(tween.from.x, tween.to.x, ratioPassed), easeInOutExpo(tween.from.y, tween.to.y, ratioPassed), easeInOutExpo(tween.from.z, tween.to.z, ratioPassed)); break;
									case LeanTweenType.easeInCirc:
										newVect = Vector3(easeInCirc(tween.from.x, tween.to.x, ratioPassed), easeInCirc(tween.from.y, tween.to.y, ratioPassed), easeInCirc(tween.from.z, tween.to.z, ratioPassed)); break;
									case LeanTweenType.easeOutCirc:
										newVect = Vector3(easeOutCirc(tween.from.x, tween.to.x, ratioPassed), easeOutCirc(tween.from.y, tween.to.y, ratioPassed), easeOutCirc(tween.from.z, tween.to.z, ratioPassed)); break;
									case LeanTweenType.easeInOutCirc:
										newVect = Vector3(easeInOutCirc(tween.from.x, tween.to.x, ratioPassed), easeInOutCirc(tween.from.y, tween.to.y, ratioPassed), easeInOutCirc(tween.from.z, tween.to.z, ratioPassed)); break;
									case LeanTweenType.easeInBounce:
										newVect = Vector3(easeInBounce(tween.from.x, tween.to.x, ratioPassed), easeInBounce(tween.from.y, tween.to.y, ratioPassed), easeInBounce(tween.from.z, tween.to.z, ratioPassed)); break;
									case LeanTweenType.easeOutBounce:
										newVect = Vector3(easeOutBounce(tween.from.x, tween.to.x, ratioPassed), easeOutBounce(tween.from.y, tween.to.y, ratioPassed), easeOutBounce(tween.from.z, tween.to.z, ratioPassed)); break;
									case LeanTweenType.easeInOutBounce:
										newVect = Vector3(easeInOutBounce(tween.from.x, tween.to.x, ratioPassed), easeInOutBounce(tween.from.y, tween.to.y, ratioPassed), easeInOutBounce(tween.from.z, tween.to.z, ratioPassed)); break;
									case LeanTweenType.easeInBack:
										newVect = Vector3(easeInBack(tween.from.x, tween.to.x, ratioPassed), easeInBack(tween.from.y, tween.to.y, ratioPassed), easeInBack(tween.from.z, tween.to.z, ratioPassed)); break;
									case LeanTweenType.easeOutBack:
										newVect = Vector3(easeOutBack(tween.from.x, tween.to.x, ratioPassed), easeOutBack(tween.from.y, tween.to.y, ratioPassed), easeOutBack(tween.from.z, tween.to.z, ratioPassed)); break;
									case LeanTweenType.easeInOutBack:
										newVect = Vector3(easeInOutBack(tween.from.x, tween.to.x, ratioPassed), easeInOutBack(tween.from.y, tween.to.y, ratioPassed), easeInOutBack(tween.from.z, tween.to.z, ratioPassed)); break;
									case LeanTweenType.easeInElastic:
										newVect = Vector3(easeInElastic(tween.from.x, tween.to.x, ratioPassed), easeInElastic(tween.from.y, tween.to.y, ratioPassed), easeInElastic(tween.from.z, tween.to.z, ratioPassed)); break;
									case LeanTweenType.easeOutElastic:
										newVect = Vector3(easeOutElastic(tween.from.x, tween.to.x, ratioPassed), easeOutElastic(tween.from.y, tween.to.y, ratioPassed), easeOutElastic(tween.from.z, tween.to.z, ratioPassed)); break;
									case LeanTweenType.easeInOutElastic:
										newVect = Vector3(easeInOutElastic(tween.from.x, tween.to.x, ratioPassed), easeInOutElastic(tween.from.y, tween.to.y, ratioPassed), easeInOutElastic(tween.from.z, tween.to.z, ratioPassed)); break;
									case LeanTweenType.punch:
										tween.animationCurve = LeanTween.punch;
										tween.to.x = tween.from.x + tween.to.x;
										tween.to.y = tween.from.y + tween.to.y;
										tween.to.z = tween.from.z + tween.to.z;
										if(tweenAction==TweenAction.ROTATE || tweenAction==TweenAction.ROTATE_LOCAL){
											tween.to.x = closestRot(tween.from.x, tween.to.x);
											tween.to.y = closestRot(tween.from.y, tween.to.y);
											tween.to.z = closestRot(tween.from.z, tween.to.z);
										}
										newVect = tweenOnCurveVector(tween, ratioPassed); break;
								}
							}else{
								fromVect = tween.from;
								toVect = tween.to;
								newVect.x = tweenFunc(fromVect.x, toVect.x, ratioPassed);
								newVect.y = tweenFunc(fromVect.y, toVect.y, ratioPassed);
								newVect.z = tweenFunc(fromVect.z, toVect.z, ratioPassed);
							}
						}
						 
						if(tweenAction==TweenAction.MOVE){
							trans.position = newVect;
					    }else if(tweenAction==TweenAction.MOVE_LOCAL){
							trans.localPosition = newVect;
					    }else if(tweenAction==TweenAction.ROTATE){
					    	trans.eulerAngles = newVect;
					    }else if(tweenAction==TweenAction.ROTATE_LOCAL){
					    	trans.localEulerAngles = newVect;
					    }else if(tweenAction==TweenAction.SCALE){
					    	trans.localScale = newVect;
					    }else if(tweenAction==TweenAction.GUI_MOVE){
					    	tween.ltRect._rect.x = newVect.x;
					    	tween.ltRect._rect.y = newVect.y;
					    }else if(tweenAction==TweenAction.GUI_SCALE){
					    	tween.ltRect._rect.width = newVect.x;
					    	tween.ltRect._rect.height = newVect.y;
					    }else if(tweenAction==TweenAction.GUI_ALPHA){
					    	tween.ltRect.alpha = newVect.x;
					    }else if(tweenAction==TweenAction.GUI_ROTATE){
					    	tween.ltRect.rotation = newVect.x;
					    }
					}

					if(tween.optional!=null){
						var onUpdate = optionalItems[&quot;onUpdate&quot;];
						if(onUpdate!=null){
							var updateParam:Hashtable = optionalItems[&quot;onUpdateParam&quot;];
							if(tweenAction==TweenAction.VALUE3){
								if(onUpdate.GetType() == String){
									onUpdateS = onUpdate as String;
									if (optionalItems[&quot;onUpdateTarget&quot;]!=null){
										customTarget = optionalItems[&quot;onUpdateTarget&quot;];
										customTarget.BroadcastMessage( onUpdateS, newVect );
									}else{
										trans.gameObject.BroadcastMessage( onUpdateS, newVect );
									}
								}else {
									if(updateParam!=null){ 
										var onUpdateA:System.Action.&lt;Vector3,Hashtable&gt; = onUpdate as System.Action.&lt;Vector3,Hashtable&gt;;
										onUpdateA( newVect, updateParam );
									}else {
										var onUpdateB:System.Action.&lt;Vector3&gt; = onUpdate as System.Action.&lt;Vector3&gt;;
										onUpdateB(newVect);
									}
								}
							}else{
								if(onUpdate.GetType() == String){
									onUpdateS = onUpdate as String;
									if (optionalItems[&quot;onUpdateTarget&quot;]!=null){
										customTarget = optionalItems[&quot;onUpdateTarget&quot;];
										customTarget.BroadcastMessage( onUpdateS, val );
									}else{
										trans.gameObject.BroadcastMessage( onUpdateS, val );
									}
								}else {
									if(updateParam!=null){ 
										var onUpdateC:System.Action.&lt;float,Hashtable&gt; = onUpdate as System.Action.&lt;float,Hashtable&gt;;
										onUpdateC( val, updateParam );
									}else {
										var onUpdateD:System.Action.&lt;float&gt; = onUpdate as System.Action.&lt;float&gt;;
										if(onUpdateD!=null){
											onUpdateD(val);
										}else{
											onUpdateF = onUpdate;
											onUpdateF(val);
										}
									}
								}
							}
							
						}
					}
				}
				
				if(isTweenFinished){
					if(tweenAction==TweenAction.GUI_ROTATE){
						tween.ltRect.rotateFinished = true;
					}
					&#x2F;&#x2F; Debug.Log(&quot;tween.loopCount:&quot;+tween.loopCount);
					if(tween.loopType==LeanTweenType.once || tween.loopCount==1){
						var callback:Function;
						var callbackS:String;
						var callbackParam;
						if(tween.optional!=null &amp;&amp; tween.trans!=null){
							if(optionalItems[&quot;onComplete&quot;]!=null){
								if(optionalItems[&quot;onComplete&quot;].GetType()==String){
									callbackS = optionalItems[&quot;onComplete&quot;] as String;
								}else{
									callback = optionalItems[&quot;onComplete&quot;] as Function;
								}
							}
							callbackParam = optionalItems[&quot;onCompleteParam&quot;];
						}
						removeTween(i);
						if(callback!=null){
							if(callbackParam) callback( callbackParam );
							else callback();
						}else if(callbackS!=null){
							if (optionalItems[&quot;onCompleteTarget&quot;]!=null){
								customTarget = optionalItems[&quot;onCompleteTarget&quot;];
								if(callbackParam!=null) customTarget.BroadcastMessage( callbackS, callbackParam );
								else customTarget.BroadcastMessage( callbackS );
							}else{
								if(callbackParam!=null) trans.gameObject.BroadcastMessage( callbackS, callbackParam );
								else trans.gameObject.BroadcastMessage( callbackS );
							}
						}
					}else{
						if(tween.loopCount&gt;=1){
							tween.loopCount--;
						}
						if(tween.loopType==LeanTweenType.clamp){
							tween.passed = Mathf.Epsilon;
							&#x2F;&#x2F; tween.delay = 0.0;
						}else if(tween.loopType==LeanTweenType.pingPong){
							tween.direction = 0.0-(tween.direction);
						}
					}
				}else if(tween.delay&lt;=0){
					tween.passed += dt*tween.direction;
				}else{
					tween.delay -= dt;
					if(tween.delay&lt;0){
						tween.passed = 0.0;&#x2F;&#x2F;-tween.delay
						tween.delay = 0.0;
					}
				}
			}
		}

		frameRendered = Time.frameCount;
	}
}

private static function removeTween( i:int ){
	tweens[i].toggle = false;
	tweens[i].optional = null;
	startSearch = i;
	&#x2F;&#x2F;Debug.Log(&quot;start search reset:&quot;+startSearch + &quot; i:&quot;+i+&quot; tweenMaxSearch:&quot;+tweenMaxSearch);
	if(i+1&gt;=tweenMaxSearch){
		&#x2F;&#x2F;Debug.Log(&quot;reset to zero&quot;);
		startSearch = 0;
		tweenMaxSearch--;
	}
}

private static var startSearch:int = 0;
private static var lastMax:int = 0;
private static var easeDefinition;
private static var errorMsg:String;

private static function pushNewTween( gameObject:GameObject, to:Vector3, time:float, tweenAction:TweenAction, optional:Hashtable ):int{
	init(maxTweens);
	if(gameObject==null){
		return -1;
	}
	
	j = 0;
	for(i = startSearch; j &lt; maxTweens; i++){
		if(i&gt;=maxTweens-1){
			i = 0;
		}
		&#x2F;&#x2F;Debug.Log(&quot;tweens[&quot;+i+&quot;]:&quot;+tweens[i].toggle);
		if(tweens[i].toggle==false){
			if(i+1&gt;tweenMaxSearch){
				tweenMaxSearch = i+1;
				&#x2F;&#x2F;Debug.Log(&quot;tweenMaxSearch:&quot;+tweenMaxSearch);
			}
			startSearch = i + 1;
			break;
		}
		
		j++;
		if(j&gt;maxTweens){
			errorMsg = &quot;LeanTween - You have run out of available spaces for tweening. To avoid this error increase the number of spaces to available for tweening when you initialize the LeanTween class ex: LeanTween.init( &quot;+(maxTweens*2)+&quot; );&quot;;
			if(throwErrors) Debug.LogError(errorMsg); else Debug.Log(errorMsg);
			return -1;
		}
	}
	&#x2F;&#x2F; if(tweenMaxSearch&gt;lastMax){
	&#x2F;&#x2F; 	lastMax = tweenMaxSearch;
	&#x2F;&#x2F; 	Debug.Log(&quot;tweenMaxSearch:&quot;+tweenMaxSearch);
	&#x2F;&#x2F; }

	tween = tweens[i];
	tween.toggle = true;
	tween.trans = gameObject.transform;
	tween.to = to;
	tween.time = time;
	tween.passed = 0.0;
	tween.type = tweenAction;
	tween.delay = 0.0;
	tween.id = i;
	tween.useEstimatedTime = false;
	tween.useFrames = false;
	tween.animationCurve = null;
	tween.easeType = LeanTweenType.linear;
	tween.loopType = LeanTweenType.once;
	tween.direction = 1.0;
	tween.hasInitialized = false;

	if(optional!=null &amp;&amp; optional!=emptyHash){
		easeDefinition = optional[&quot;ease&quot;];
		var optionsNotUsed:int = 0;
		if(easeDefinition!=null){
			tween.easeType = LeanTweenType.notUsed;
			if( easeDefinition.GetType() == LeanTweenType ){
				tween.easeType = easeDefinition;
			}else if(easeDefinition.GetType() == AnimationCurve){
				tween.animationCurve = easeDefinition as AnimationCurve;
			}else{
				tween.tweenFunc = easeDefinition as Function;
				if(tween.tweenFunc==LeanTween.easeOutQuad){
					tween.easeType = LeanTweenType.easeOutQuad;
				}else if(tween.tweenFunc==LeanTween.easeInQuad){
					tween.easeType = LeanTweenType.easeInQuad;
				}else if(tween.tweenFunc==LeanTween.easeInOutQuad){
					tween.easeType = LeanTweenType.easeInOutQuad;
				}
			}
			optionsNotUsed++;
		}
		if(optional.Count &gt; optionsNotUsed){
			if(optional[&quot;rect&quot;]!=null){
				tween.ltRect = optional[&quot;rect&quot;];
				optionsNotUsed++;
			}
			if(optional[&quot;path&quot;]!=null){
				tween.path = optional[&quot;path&quot;];
				optionsNotUsed++;
			}
			if(optional[&quot;delay&quot;]!=null){
				tween.delay = optional[&quot;delay&quot;];
				optionsNotUsed++;
			}
			if(optional[&quot;useEstimatedTime&quot;]!=null){
				tween.useEstimatedTime = optional[&quot;useEstimatedTime&quot;];
				optionsNotUsed++;
			}
			if(optional[&quot;useFrames&quot;]!=null){
				tween.useFrames = optional[&quot;useFrames&quot;];
				optionsNotUsed++;
			}
			if(optional[&quot;loopType&quot;]!=null){
				tween.loopType = optional[&quot;loopType&quot;];
				optionsNotUsed++;
			}
			if(optional[&quot;repeat&quot;]!=null){
				tween.loopCount = optional[&quot;repeat&quot;];
				if(tween.loopType==LeanTweenType.once)
					tween.loopType = LeanTweenType.clamp;
				optionsNotUsed++;
			}
		}
		if(optional.Count &lt;= optionsNotUsed){
			tween.optional = null;  &#x2F;&#x2F; nothing else is used with the extra piece, so set to null
		}else{
			tween.optional = optional;
		}
	}else{
		tween.optional = null;
	}
	&#x2F;&#x2F; Debug.Log(&quot;pushing new tween[&quot;+i+&quot;]:&quot;+tweens[i]);
	
	return tweens[i].id;
}

public static function add(a: Vector3[], b: Vector3): Vector3[]{
	var c:Vector3[] = new Vector3[ a.Length ];
	for(i=0; i&lt;a.Length; i++){
		c[i] = a[i] + b;
	}

	return c;
}

public static function h( arr:Object[] ):Hashtable{
	if(arr.Length%2==1){
		var errorMsg:String = &quot;LeanTween - You have attempted to create a Hashtable with an odd number of values.&quot;;
		if(throwErrors) Debug.LogError( errorMsg ); else Debug.Log( errorMsg );
		return null;
	}
	var hash:Hashtable = new Hashtable();
	for(i = 0; i &lt; arr.Length; i += 2){
		hash.Add(arr[i] as String, arr[i+1]);
	}

	return hash;
}

public static function closestRot( from:float, to:float ):float{
	var minusWhole:float = 0 - (360 - to);
	var plusWhole:float = 360 + to;
	var toDiffAbs:float = Mathf.Abs( to-from );
	var minusDiff:float = Mathf.Abs(minusWhole-from);
	var plusDiff:float = Mathf.Abs(plusWhole-from);
	if( toDiffAbs &lt; minusDiff &amp;&amp; toDiffAbs &lt; plusDiff ){
		return to;
	}else {
		if(minusDiff &lt; plusDiff){
			return minusWhole;
		}else{
			return plusWhole;
		}
	}
}

&#x2F;**
* Cancel all tweens that are currently targeting the gameObject
* 
* @method LeanTween.cancel
* @param {GameObject} gameObject:GameObject whose tweens you want to cancel
*&#x2F;
public static function cancel( gameObject:GameObject ){
	var trans:Transform = gameObject.transform;
	for(var i:int = 0; i &lt; tweenMaxSearch; i++){
		if(tweens[i].trans===trans)
			removeTween(i);
	}
}

&#x2F;**
* Cancel a specific tween for a gameObject
* 
* @method LeanTween.cancel
* @param {GameObject} gameObject:GameObject GameObject whose tweens you want to cancel
* @param {int} id:int Id of the tween you want to cancel ex: var id:int = LeanTween.MoveX(gameObject, 5, 1.0);
*&#x2F;
public static function cancel( gameObject:GameObject, id:int ){
	var trans:Transform = gameObject.transform;
	for(var i:int = 0; i &lt; tweenMaxSearch; i++){
		if(tweens[i].trans===trans &amp;&amp; tweens[i].id == id)
			removeTween(i);
	}
}

&#x2F;**
* Cancel a specific tween for a gameObject (GUI Methods)
* 
* @method LeanTween.cancel
* @param {LTRect} ltRect:LTRect LTRect whose tweens you want to cancel
* @param {int} id:int Id of the tween you want to cancel ex: var id:int = LeanTween.rotate(ltRect, 180);
*&#x2F;
public static function cancel( ltRect:LTRect, id:int ){
	for(var i:int = 0; i &lt; tweenMaxSearch; i++){
		if(tweens[i].id == id &amp;&amp; tweens[i].ltRect===ltRect)
			removeTween(i);
	}
}


public static function description( id:int ):LeanTweenDescr{
	return d( id );
}

public static function d( id:int ):LeanTweenDescr{
	if(tweens[id] &amp;&amp; tweens[id].id == id)
		return tweens[id];
	for(var i:int = 0; i &lt; tweenMaxSearch; i++){
		if(tweens[i].id == id)
			return tweens[i];
	}
	return null;
}

&#x2F;**
* Pause a specific tween for a gameObject
* 
* @method LeanTween.pause
* @param {GameObject} gameObject:GameObject GameObject whose tweens you want to pause
* @param {int} id:int Id of the tween you want to cancel ex: var id:int = LeanTween.MoveX(gameObject, 5, 1.0);
*&#x2F;
public static function pause( gameObject:GameObject, id:int ){
	var trans:Transform = gameObject.transform;
	for(var i:int = 0; i &lt; tweenMaxSearch; i++){
		if(tweens[i].trans===trans &amp;&amp; tweens[i].id == id){
			if(tweens[i].optional==null || tweens[i].optional.Count==0){
				tweens[i].optional = new Hashtable();
			}
			tweens[i].optional[&quot;directionSaved&quot;] = tweens[i].direction;
			tweens[i].direction = 0.0;
		}
	}
}

&#x2F;**
* Pause a specific tween for a gameObject
* 
* @method LeanTween.pause
* @param {GameObject} gameObject:GameObject GameObject whose tweens you want to pause
*&#x2F;
public static function pause( gameObject:GameObject ){
	var trans:Transform = gameObject.transform;
	for(var i:int = 0; i &lt; tweenMaxSearch; i++){
		if(tweens[i].trans===trans){
			if(tweens[i].optional==null || tweens[i].optional.Count==0){
				tweens[i].optional = new Hashtable();
			}
			tweens[i].optional[&quot;directionSaved&quot;] = tweens[i].direction;
			tweens[i].direction = 0.0;
		}
	}
}

&#x2F;**
* Pause a specific tween for a gameObject
* 
* @method LeanTween.resume
* @param {GameObject} gameObject:GameObject GameObject whose tweens you want to resume
* @param {int} id:int Id of the tween you want to resume ex: var id:int = LeanTween.MoveX(gameObject, 5, 1.0);
*&#x2F;
public static function resume( gameObject:GameObject, id:int ){
	var trans:Transform = gameObject.transform;
	for(var i:int = 0; i &lt; tweenMaxSearch; i++){
		if(tweens[i].trans===trans &amp;&amp; tweens[i].id == id)
			tweens[i].direction = tweens[i].optional[&quot;directionSaved&quot;];
	}
}

&#x2F;**
* Pause a specific tween for a gameObject
* 
* @method LeanTween.resume
* @param {GameObject} gameObject:GameObject GameObject whose tweens you want to resume
*&#x2F;
public static function resume( gameObject:GameObject ){
	var trans:Transform = gameObject.transform;
	for(var i:int = 0; i &lt; tweenMaxSearch; i++){
		if(tweens[i].trans===trans)
			tweens[i].direction = tweens[i].optional[&quot;directionSaved&quot;];
	}
}

public static function isTweening( gameObject:GameObject ):boolean{
	var trans:Transform = gameObject.transform;
	for(i = 0; i &lt; tweenMaxSearch; i++){
		if(tweens[i].toggle &amp;&amp; tweens[i].trans===trans)
			return true;
	}
	return false;
}

public static function isTweening( ltRect:LTRect ):boolean{
	for(i = 0; i &lt; tweenMaxSearch; i++){
		if(tweens[i].toggle &amp;&amp; tweens[i].ltRect===ltRect)
			return true;
	}
	return false;
}

public static function drawBezierPath(a:Vector3, b:Vector3, c:Vector3, d:Vector3){
    var last:Vector3 = a;
    var p:Vector3;
    var aa:Vector3 = (-a + 3*(b-c) + d);
	var bb:Vector3 = 3*(a+c) - 6*b;
	var cc:Vector3 = 3*(b-a);
	var t:float;
    for(var k:float = 1.0 ; k &lt;= 30.0; k++){
    	t = k &#x2F; 30.0;
    	p = ((aa* t + (bb))* t + cc)* t + a;
	    Gizmos.DrawLine(last, p);
	    last = p;
	}
}

&#x2F;**
* Tween any particular value, it does not need to be tied to any particular type or GameObject
* 
* @method LeanTween.value
* @param {Function} callOnUpdate:Function The function that is called on every Update frame, this function needs to accept a float value ex: function updateValue( val:float ){ }
* @param {float} from:float The original value to start the tween from
* @param {float} to:float The value to end the tween on
* @param {float} time:float The time to complete the tween in
* @return {int} Returns an integer id that is used to distinguish this tween
*&#x2F;
public static function value(callOnUpdate:System.Action.&lt;float&gt;, from:float, to:float, time:float, optional:Hashtable):int{
	return value( tweenEmpty, callOnUpdate, from, to, time, optional );
}
public static function value(callOnUpdate:System.Action.&lt;float&gt;, from:float, to:float, time:float, optional:Object[]):int{
	return value( tweenEmpty, callOnUpdate, from, to, time, h(optional) );
}
public static function value(callOnUpdate:System.Action.&lt;float,Hashtable&gt;, from:float, to:float, time:float, optional:Hashtable):int{
	return value( tweenEmpty, callOnUpdate, from, to, time, optional );
}
public static function value(callOnUpdate:System.Action.&lt;float,Hashtable&gt;, from:float, to:float, time:float, optional:Object[]):int{
	return value( tweenEmpty, callOnUpdate, from, to, time, h(optional) );
}
public static function value(gameObject:GameObject, callOnUpdate:System.Action.&lt;float,Hashtable&gt;, from:float, to:float, time:float, optional:Object[]):int{
	return value( gameObject, callOnUpdate, from, to, time, h(optional) );
}
public static function value(gameObject:GameObject, callOnUpdate:String, from:float, to:float, time:float, optional:Hashtable):int{
	if(optional==null || optional.Count==0)
		optional = new Hashtable();
		
	optional[&quot;onUpdate&quot;] = callOnUpdate;
	var id:int = pushNewTween( gameObject, Vector3(to,0,0), time, TweenAction.CALLBACK, optional );
	tweens[id].from = new Vector3(from,0,0);
	return id;
}
public static function value(gameObject:GameObject, callOnUpdate:String, from:float, to:float, time:float, optional:Object[]):int{
	return value(gameObject, callOnUpdate, from, to, time, h(optional)); 
}
public static function value(gameObject:GameObject, callOnUpdate:String, from:float, to:float, time:float):int{
	return value(gameObject, callOnUpdate, from, to, time, emptyHash); 
}

public static function value(gameObject:GameObject, callOnUpdate:System.Action.&lt;float&gt;, from:float, to:float, time:float):int{
	return value(gameObject, callOnUpdate, from, to, time, emptyHash); 
}

&#x2F;**
* Tween any particular value, it does not need to be tied to any particular type or GameObject
* 
* @method LeanTween.value
* @param {GameObject} gameObject:GameObject GameObject with which to tie the tweening with. This is only used when you need to cancel this tween, it does not actually perform any operations on this gameObject
* @param {Function} callOnUpdate:Function The function that is called on every Update frame, this function needs to accept a float value ex: function updateValue( val:float ){ }
* @param {float} from:float The original value to start the tween from
* @param {float} to:float The value to end the tween on
* @param {float} time:float The time to complete the tween in
* @param {Hashtable} optional:Hashtable The time to complete the tween in
* @return {int} Returns an integer id that is used to distinguish this tween
*&#x2F;
public static function value(gameObject:GameObject, callOnUpdate:System.Action.&lt;float&gt;, from:float, to:float, time:float, optional:Hashtable):int{
	if(optional==null || optional.Count==0)
		optional = new Hashtable();
		
	optional[&quot;onUpdate&quot;] = callOnUpdate;
	var id:int = pushNewTween( gameObject, Vector3(to,0,0), time, TweenAction.CALLBACK, optional );
	tweens[id].from = new Vector3(from,0,0);
	return id;
}
public static function value(gameObject:GameObject, callOnUpdate:System.Action.&lt;float,Hashtable&gt;, from:float, to:float, time:float, optional:Hashtable):int{
	if(optional==null || optional.Count==0)
		optional = new Hashtable();
		
	optional[&quot;onUpdate&quot;] = callOnUpdate;
	var id:int = pushNewTween( gameObject, Vector3(to,0,0), time, TweenAction.CALLBACK, optional );
	tweens[id].from = new Vector3(from,0,0);
	return id;
}

public static function value(gameObject:GameObject, callOnUpdate:System.Action.&lt;float&gt;, from:float, to:float, time:float, optional:Object[]):int{
	return value(gameObject, callOnUpdate, from, to, time, h(optional)); 
}

&#x2F;**
* Tween any particular value (Vector3), it does not need to be tied to any particular type or GameObject
* 
* @method LeanTween.value
* @param {GameObject} gameObject:GameObject Gameobject that you wish to attach the tween to
* @param {Function} callOnUpdate:Function The function that is called on every Update frame, this function needs to accept a float value ex: function updateValue( val:Vector3 ){ }
* @param {float} from:Vector3 The original value to start the tween from
* @param {Vector3} to:Vector3 The final Vector3 with which to tween to
* @param {float} time:float The time to complete the tween in
* @param {Hashtable} optional:Hashtable Hashtable where you can pass &lt;a href=&quot;#optional&quot;&gt;optional items&lt;&#x2F;a&gt;.
* @return {int} Returns an integer id that is used to distinguish this tween
*&#x2F;
public static function value(gameObject:GameObject, callOnUpdate:System.Action.&lt;Vector3&gt;, from:Vector3, to:Vector3, time:float, optional:Hashtable):int{
	if(optional==null || optional.Count==0)
		optional = new Hashtable();
		
	optional[&quot;onUpdate&quot;] = callOnUpdate;
	var id:int = pushNewTween( gameObject, to, time, TweenAction.VALUE3, optional );
	tweens[id].from = from;
	return id;
}
public static function value(gameObject:GameObject, callOnUpdate:System.Action.&lt;Vector3,Hashtable&gt;, from:Vector3, to:Vector3, time:float, optional:Hashtable):int{
	if(optional==null || optional.Count==0)
		optional = new Hashtable();
		
	optional[&quot;onUpdate&quot;] = callOnUpdate;
	var id:int = pushNewTween( gameObject, to, time, TweenAction.VALUE3, optional );
	tweens[id].from = from;
	return id;
}
public static function value(gameObject:GameObject, callOnUpdate:System.Action.&lt;Vector3&gt;, from:Vector3, to:Vector3, time:float, optional:Object[]):int{
	return value(gameObject, callOnUpdate, from, to, time, h(optional)); 
}
public static function value(gameObject:GameObject, callOnUpdate:System.Action.&lt;Vector3,Hashtable&gt;, from:Vector3, to:Vector3, time:float, optional:Object[]):int{
	return value(gameObject, callOnUpdate, from, to, time, h(optional)); 
}

&#x2F;**
* Tween any particular value (Vector3), it does not need to be tied to any particular type or GameObject
* 
* @method LeanTween.value
* @param {GameObject} gameObject:GameObject Gameobject that you wish to attach the tween to
* @param {String} callOnUpdate:String The function that is called on every Update frame, this function needs to accept a float value ex: function updateValue( val:Vector3 ){ }
* @param {float} from:Vector3 The original value to start the tween from
* @param {Vector3} to:Vector3 The final Vector3 with which to tween to
* @param {float} time:float The time to complete the tween in
* @param {Hashtable} optional:Hashtable Hashtable where you can pass &lt;a href=&quot;#optional&quot;&gt;optional items&lt;&#x2F;a&gt;.
* @return {int} Returns an integer id that is used to distinguish this tween
*&#x2F;
public static function value(gameObject:GameObject, callOnUpdate:String, from:Vector3, to:Vector3, time:float, optional:Hashtable):int{
	if(optional==null || optional.Count==0)
		optional = new Hashtable();
		
	optional[&quot;onUpdate&quot;] = callOnUpdate;
	var id:int = pushNewTween( gameObject, to, time, TweenAction.VALUE3, optional );
	tweens[id].from = from;
	return id;
}
public static function value(gameObject:GameObject, callOnUpdate:String, from:Vector3, to:Vector3, time:float, optional:Object[]):int{
	return value(gameObject, callOnUpdate, from, to, time, h(optional)); 
}

&#x2F;**
* Rotate a GameObject, to values are in passed in degrees
* 
* @method LeanTween.rotate
* @param {GameObject} gameObject:GameObject Gameobject that you wish to rotate
* @param {Vector3} to:Vector3 The final rotation with which to rotate to
* @param {float} time:float The time to complete the tween in
* @return {int} Returns an integer id that is used to distinguish this tween
* @example &lt;i&gt;Javascript:&lt;&#x2F;i&gt;&lt;br&gt;
* LeanTween.rotate(cube, Vector3(180,30,0), 1.5);
* &lt;br&gt;&lt;br&gt;
* &lt;i&gt;C#: &lt;&#x2F;i&gt; &lt;br&gt;
* LeanTween.rotate(cube, Vector3(180f,30f,0f), 1.5f);&lt;br&gt;
*&#x2F;
public static function rotate(gameObject:GameObject, to:Vector3, time:float):int{
	return rotate( gameObject, to, time, emptyHash );
}

&#x2F;**
* Rotate a GameObject, to values that are in passed in degrees
* 
* @method LeanTween.rotate
* @param {GameObject} gameObject:GameObject Gameobject that you wish to rotate
* @param {Vector3} to:Vector3 The final rotation with which to rotate to
* @param {float} time:float The time to complete the tween in
* @param {Hashtable} optional:Hashtable Hashtable where you can pass &lt;a href=&quot;#optional&quot;&gt;optional items&lt;&#x2F;a&gt;.
* @return {int} Returns an integer id that is used to distinguish this tween
* @example &lt;i&gt;Javascript:&lt;&#x2F;i&gt;&lt;br&gt;
* LeanTween.rotate(cube, Vector3(180,30,0), 1.5, {&quot;ease&quot;:LeanTween.easeInOutQuad, &quot;onComplete&quot;:finishedTweening});
* &lt;br&gt;&lt;br&gt;
* &lt;i&gt;C#: &lt;&#x2F;i&gt; &lt;br&gt;
* Hashtable optional = new Hashtable();&lt;br&gt;
* optional.Add(&quot;ease&quot;:LeanTweenType.easeInOutQuad);&lt;br&gt;
* optional.Add(&quot;onComplete&quot;:&quot;finishedTweening&quot;);&lt;br&gt;
* optional.Add(&quot;onCompleteTarget&quot;:gameObject);&lt;br&gt;
* LeanTween.rotate(cube, Vector3(180f,30f,0f), 1.5f, optional);&lt;br&gt;
*&#x2F;
public static function rotate(gameObject:GameObject, to:Vector3, time:float, optional:Hashtable):int{
	return pushNewTween( gameObject, to, time, TweenAction.ROTATE, optional );
}

public static function rotate(gameObject:GameObject, to:Vector3, time:float, optional:Object[]):int{
	return rotate( gameObject, to, time, h( optional ) );
}

public static function rotate(ltRect:LTRect, to:float, time:float, optional:Hashtable):int{
	init();
	if( optional==null || optional.Count == 0 )
		optional = new Hashtable();

	optional[&quot;rect&quot;] = ltRect;
	return pushNewTween( tweenEmpty, Vector3(to,0,0), time, TweenAction.GUI_ROTATE, optional );
}

&#x2F;**
* Rotate a GUI element (using an LTRect object), to a value that is in degrees
* 
* @method LeanTween.rotate
* @param {LTRect} ltRect:LTRect LTRect that you wish to rotate
* @param {float} to:float The final rotation with which to rotate to
* @param {float} time:float The time to complete the tween in
* @param {Array} optional:Array Object Array where you can pass &lt;a href=&quot;#optional&quot;&gt;optional items&lt;&#x2F;a&gt;.
* @return {int} Returns an integer id that is used to distinguish this tween
* @example &lt;i&gt;Javascript:&lt;&#x2F;i&gt;&lt;br&gt;
* if(GUI.Button(buttonRect.rect, &quot;Rotate&quot;))&lt;br&gt;
*	LeanTween.rotate( buttonRect4, 150.0, 1.0, [&quot;ease&quot;,LeanTween.easeOutElastic]);&lt;br&gt;
* GUI.matrix = Matrix4x4.identity;&lt;br&gt;
* &lt;br&gt;&lt;br&gt;
* &lt;i&gt;C#: &lt;&#x2F;i&gt; &lt;br&gt;
* if(GUI.Button(buttonRect.rect, &quot;Rotate&quot;))&lt;br&gt;
*	LeanTween.rotate( buttonRect4, 150.0, 1.0, new object[]{&quot;ease&quot;,LeanTween.easeOutElastic});&lt;br&gt;
* GUI.matrix = Matrix4x4.identity;&lt;br&gt;
*&#x2F;
public static function rotate(ltRect:LTRect, to:float, time:float, optional:Object[]):int{
	return rotate( ltRect, to, time, h(optional) );
}

&#x2F;**
* Rotate a GameObject only on the X axis
* 
* @method LeanTween.rotateX
* @param {GameObject} gameObject:GameObject Gameobject that you wish to rotate
* @param {float} to:float The final x-axis rotation with which to rotate
* @param {float} time:float The time to complete the rotation in
*&#x2F;
public static function rotateX(gameObject:GameObject, to:float, time:float):int{
	return rotateX( gameObject, to, time, emptyHash );
}
&#x2F;**
* Rotate a GameObject only on the X axis
* 
* @method LeanTween.rotateX
* @param {GameObject} gameObject:GameObject Gameobject that you wish to rotate
* @param {float} to:float The final x-axis rotation with which to rotate
* @param {float} time:float The time to complete the rotation in
* @param {Hashtable} optional:Hashtable Hashtable where you can pass &lt;a href=&quot;#optional&quot;&gt;optional items&lt;&#x2F;a&gt;.
*&#x2F;
public static function rotateX(gameObject:GameObject, to:float, time:float, optional:Hashtable):int{
	return pushNewTween( gameObject, Vector3(to,0,0), time, TweenAction.ROTATE_X, optional );
}

public static function rotateX(gameObject:GameObject, to:float, time:float, optional:Object[]):int{
	return rotateX( gameObject, to, time, h(optional) );
}

&#x2F;**
* Rotate a GameObject only on the Y axis
* 
* @method LeanTween.rotateY
* @param {GameObject} gameObject:GameObject Gameobject that you wish to rotate
* @param {float} to:float The final y-axis rotation with which to rotate
* @param {float} time:float The time to complete the rotation in
*&#x2F;
public static function rotateY(gameObject:GameObject, to:float, time:float):int{
	return rotateY( gameObject, to, time, emptyHash );
}
&#x2F;**
* Rotate a GameObject only on the Y axis
* 
* @method LeanTween.rotateY
* @param {GameObject} gameObject:GameObject Gameobject that you wish to rotate
* @param {float} to:float The final y-axis rotation with which to rotate
* @param {float} time:float The time to complete the rotation in
* @param {Hashtable} optional:Hashtable Hashtable where you can pass &lt;a href=&quot;#optional&quot;&gt;optional items&lt;&#x2F;a&gt;.
*&#x2F;
public static function rotateY(gameObject:GameObject, to:float, time:float, optional:Hashtable):int{
	return pushNewTween( gameObject, Vector3(to,0,0), time, TweenAction.ROTATE_Y, optional );
}

public static function rotateY(gameObject:GameObject, to:float, time:float, optional:Object[]):int{
	return rotateY( gameObject, to, time, h(optional) );
}

&#x2F;**
* Rotate a GameObject only on the Z axis
* 
* @method LeanTween.rotateZ
* @param {GameObject} gameObject:GameObject Gameobject that you wish to rotate
* @param {float} to:float The final z-axis rotation with which to rotate
* @param {float} time:float The time to complete the rotation in
*&#x2F;
public static function rotateZ(gameObject:GameObject, to:float, time:float):int{
	return rotateZ( gameObject, to, time, emptyHash );
}
&#x2F;**
* Rotate a GameObject only on the Z axis
* 
* @method LeanTween.rotateZ
* @param {GameObject} gameObject:GameObject Gameobject that you wish to rotate
* @param {float} to:float The final z-axis rotation with which to rotate
* @param {float} time:float The time to complete the rotation in
* @param {Hashtable} optional:Hashtable Hashtable where you can pass &lt;a href=&quot;#optional&quot;&gt;optional items&lt;&#x2F;a&gt;.
*&#x2F;
public static function rotateZ(gameObject:GameObject, to:float, time:float, optional:Hashtable):int{
	return pushNewTween( gameObject, Vector3(to,0,0), time, TweenAction.ROTATE_Z, optional );
}

public static function rotateZ(gameObject:GameObject, to:float, time:float, optional:Object[]):int{
	return rotateZ( gameObject, to, time, h(optional) );
}
&#x2F;**
* Rotate a GameObject in the objects local space (on the transforms localEulerAngles object)
* 
* @method LeanTween.rotateLocal
* @param {GameObject} gameObject:GameObject Gameobject that you wish to rotate
* @param {Vector3} to:Vector3 The final rotation with which to rotate to
* @param {float} time:float The time to complete the rotation in
* @param {Hashtable} optional:Hashtable Hashtable where you can pass &lt;a href=&quot;#optional&quot;&gt;optional items&lt;&#x2F;a&gt;.
*&#x2F;
public static function rotateLocal(gameObject:GameObject, to:Vector3, time:float, optional:Hashtable):int{
	return pushNewTween( gameObject, to, time, TweenAction.ROTATE_LOCAL, optional );
}

public static function rotateLocal(gameObject:GameObject, to:Vector3, time:float, optional:Object[]):int{
	return rotateLocal( gameObject, to, time, h(optional) );
}

public static function rotateLocal(gameObject:GameObject, to:Vector3, time:float):int{
	return rotateLocal( gameObject, to, time, emptyHash );
}

&#x2F;**
* Rotate a GameObject in the objects around an axis 
* 
* @method LeanTween.rotateAround
* @param {GameObject} gameObject:GameObject Gameobject that you wish to rotate
* @param {Vector3} axis:Vector3 The final rotation with which to rotate to
* @param {float} add:float Rotate in x degrees
* @param {float} time:float The time to complete the rotation in
* @param {Hashtable} optional:Hashtable Hashtable where you can pass &lt;a href=&quot;#optional&quot;&gt;optional items&lt;&#x2F;a&gt;.
*&#x2F;
&#x2F;&#x2F; public static function rotateAround(gameObject:GameObject, localPoint:Vector3, axis:Vector3, add:float, time:float, optional:Hashtable):int{
&#x2F;&#x2F; 	if(optional==null || optional.Count==0)
&#x2F;&#x2F; 		optional = new Hashtable();
		
&#x2F;&#x2F; 	optional[&quot;axis&quot;] = axis;
&#x2F;&#x2F; 	optional[&quot;point&quot;] = localPoint;
&#x2F;&#x2F; 	return pushNewTween( gameObject, Vector3(add,0,0), time, TweenAction.ROTATE_AROUND, optional );
&#x2F;&#x2F; }

public static function rotateAround(gameObject:GameObject, axis:Vector3, add:float, time:float, optional:Hashtable):int{
	if(optional==null || optional.Count==0)
		optional = new Hashtable();
		
	optional[&quot;axis&quot;] = axis;
	if(optional[&quot;point&quot;]!=null)
		optional[&quot;point&quot;] = Vector3.zero;
	return pushNewTween( gameObject, Vector3(add,0,0), time, TweenAction.ROTATE_AROUND, optional );
}

public static function rotateAround(gameObject:GameObject, axis:Vector3, add:float, time:float, optional:Object[]):int{
	return rotateAround(gameObject, axis, add, time, h(optional));
}

&#x2F;**
* Move a GameObject along the x-axis
* 
* @method LeanTween.moveX
* @param {GameObject} gameObject:GameObject Gameobject that you wish to move
* @param {float} to:float The final position with which to move to
* @param {float} time:float The time to complete the move in
* @param {Hashtable} optional:Hashtable Hashtable where you can pass &lt;a href=&quot;#optional&quot;&gt;optional items&lt;&#x2F;a&gt;.
*&#x2F;
public static function moveX(gameObject:GameObject, to:float, time:float, optional:Hashtable):int{
	return pushNewTween( gameObject, Vector3(to,0,0), time, TweenAction.MOVE_X, optional );
}
public static function moveX(gameObject:GameObject, to:float, time:float, optional:Object[]):int{
	return moveX( gameObject, to, time, h(optional) );
}
public static function moveX(gameObject:GameObject, to:float, time:float):int{
	return moveX( gameObject, to, time, emptyHash );
}

&#x2F;**
* Move a GameObject along the y-axis
* 
* @method LeanTween.moveY
* @param {GameObject} gameObject:GameObject Gameobject that you wish to move
* @param {float} to:float The final position with which to move to
* @param {float} time:float The time to complete the move in
* @param {Hashtable} optional:Hashtable Hashtable where you can pass &lt;a href=&quot;#optional&quot;&gt;optional items&lt;&#x2F;a&gt;.
*&#x2F;
public static function moveY(gameObject:GameObject, to:float, time:float, optional:Hashtable):int{
	return pushNewTween( gameObject, Vector3(to,0,0), time, TweenAction.MOVE_Y, optional );
}
public static function moveY(gameObject:GameObject, to:float, time:float, optional:Object[]):int{
	return moveY( gameObject, to, time, h(optional) );
}
public static function moveY(gameObject:GameObject, to:float, time:float):int{
	return moveY( gameObject, to, time, emptyHash );
}

&#x2F;**
* Move a GameObject along the z-axis
* 
* @method LeanTween.moveZ
* @param {GameObject} gameObject:GameObject Gameobject that you wish to move
* @param {float} to:float The final position with which to move to
* @param {float} time:float The time to complete the move in
* @param {Hashtable} optional:Hashtable Hashtable where you can pass &lt;a href=&quot;#optional&quot;&gt;optional items&lt;&#x2F;a&gt;.
*&#x2F;
public static function moveZ(gameObject:GameObject, to:float, time:float, optional:Hashtable):int{
	return pushNewTween( gameObject, Vector3(to,0,0), time, TweenAction.MOVE_Z, optional );
}
public static function moveZ(gameObject:GameObject, to:float, time:float, optional:Object[]):int{
	return moveZ( gameObject, to, time, h(optional) );
}
public static function moveZ(gameObject:GameObject, to:float, time:float):int{
	return moveZ( gameObject, to, time, emptyHash );
}

public static function move(gameObject:GameObject, to:Vector3, time:float):int{
	return move( gameObject, to, time, emptyHash );
}

&#x2F;**
* Move a GameObject to a certain location
* 
* @method LeanTween.move
* @param {GameObject} gameObject:GameObject Gameobject that you wish to move
* @param {Vector3} to:Vector3 The final positin with which to move to
* @param {float} time:float The time to complete the tween in
* @param {Hashtable} optional:Hashtable Hashtable where you can pass &lt;a href=&quot;#optional&quot;&gt;optional items&lt;&#x2F;a&gt;.
* @return {int} Returns an integer id that is used to distinguish this tween
* @example
* &lt;i&gt;Javascript:&lt;&#x2F;i&gt;&lt;br&gt;
* LeanTween.move(gameObject, Vector3(0,-3,5), 2.0, {&quot;ease&quot;:LeanTween.easeOutQuad});&lt;br&gt;&lt;br&gt;
* &lt;i&gt;C#:&lt;&#x2F;i&gt;&lt;br&gt;
* Hashtable optional = new Hashtable();&lt;br&gt;
* optional.Add(&quot;ease&quot;:LeanTweenType.easeOutQuad);&lt;br&gt;
* LeanTween.move(gameObject, Vector3(0f,-3f,5f), 1.5f, optional);&lt;br&gt;
*&#x2F;
public static function move(gameObject:GameObject, to:Vector3, time:float, optional:Hashtable):int{
	return pushNewTween( gameObject, to, time, TweenAction.MOVE, optional );
}

public static function move(gameObject:GameObject, to:Vector3, time:float, optional:Object[]):int{
	return move( gameObject, to, time, LeanTween.h( optional ) );
}

&#x2F;**
* Move a GameObject along a set of bezier curves
* 
* @method LeanTween.move
* @param {GameObject} gameObject:GameObject Gameobject that you wish to move
* @param {Vector3[]} path:Vector3[] A set of points that define the curve(s) ex: Point1,Handle1,Handle2,Point2,...
* @param {float} time:float The time to complete the tween in
* @param {Hashtable} optional:Hashtable Hashtable where you can pass &lt;a href=&quot;#optional&quot;&gt;optional items&lt;&#x2F;a&gt;.
* @return {int} Returns an integer id that is used to distinguish this tween
* @example
* &lt;i&gt;Javascript:&lt;&#x2F;i&gt;&lt;br&gt;
* LeanTween.move(gameObject, [Vector3(0,0,0),Vector3(1,0,0),Vector3(1,0,0),Vector3(1,0,1)], 2.0, {&quot;ease&quot;:LeanTween.easeOutQuad,&quot;orientToPath&quot;:true});&lt;br&gt;&lt;br&gt;
* &lt;i&gt;C#:&lt;&#x2F;i&gt;&lt;br&gt;
* Hashtable optional = new Hashtable();&lt;br&gt;
* optional.Add(&quot;ease&quot;:LeanTweenType.easeOutQuad);&lt;br&gt;
* optional.Add(&quot;orientToPath&quot;:true);&lt;br&gt;
* LeanTween.move(gameObject, new Vector3{Vector3(0f,0f,0f),Vector3(1f,0f,0f),Vector3(1f,0f,0f),Vector3(1f,0f,1f)}, 1.5f, optional);&lt;br&gt;
*&#x2F;
public static function move(gameObject:GameObject, to:Vector3[], time:float, optional:Hashtable):int{
	if(to.Length&lt;4){
		var errorMsg:String = &quot;LeanTween - When passing values for a vector path, you must pass four or more values!&quot;;
		if(throwErrors) Debug.LogError(errorMsg); else Debug.Log(errorMsg);
		return -1;
	}
	if(to.Length%4!=0){
		var errorMsg2:String = &quot;LeanTween - When passing values for a vector path, they must be in sets of four: controlPoint1, controlPoint2, endPoint2, controlPoint2, controlPoint2...&quot;;
		if(throwErrors) Debug.LogError(errorMsg2); else Debug.Log(errorMsg2);
		return -1;
	}

	init();
	if( optional == null )
		optional = new Hashtable();

	var ltPath:LTBezierPath = new LTBezierPath( to );
	if(optional[&quot;orientToPath&quot;])
		ltPath.orientToPath = true;
	optional[&quot;path&quot;] = ltPath;

	return pushNewTween( gameObject, Vector3(1.0,0.0,0.0), time, TweenAction.MOVE_CURVED, optional );
}

public static function move(gameObject:GameObject, to:Vector3[], time:float, optional:Object[]):int{
	return move( gameObject, to, time, LeanTween.h( optional ) );
}

&#x2F;**
* Move a GameObject along a set of bezier curves
* 
* @method LeanTween.move
* @param {GameObject} gameObject:GameObject Gameobject that you wish to move
* @param {Vector3[]} path:Vector3[] A set of points that define the curve(s) ex: Point1,Handle1,Handle2,Point2,...
* @param {float} time:float The time to complete the tween in
* @param {Hashtable} optional:Hashtable Hashtable where you can pass &lt;a href=&quot;#optional&quot;&gt;optional items&lt;&#x2F;a&gt;.
* @return {int} Returns an integer id that is used to distinguish this tween
* @example
* &lt;i&gt;Javascript:&lt;&#x2F;i&gt;&lt;br&gt;
* LeanTween.move(gameObject, [Vector3(0,0,0),Vector3(1,0,0),Vector3(1,0,0),Vector3(1,0,1)], 2.0, {&quot;ease&quot;:LeanTween.easeOutQuad,&quot;orientToPath&quot;:true});&lt;br&gt;&lt;br&gt;
* &lt;i&gt;C#:&lt;&#x2F;i&gt;&lt;br&gt;
* Hashtable optional = new Hashtable();&lt;br&gt;
* optional.Add(&quot;ease&quot;:LeanTweenType.easeOutQuad);&lt;br&gt;
* optional.Add(&quot;orientToPath&quot;:true);&lt;br&gt;
* LeanTween.move(gameObject, new Vector3{Vector3(0f,0f,0f),Vector3(1f,0f,0f),Vector3(1f,0f,0f),Vector3(1f,0f,1f)}, 1.5f, optional);&lt;br&gt;
*&#x2F;
public static function moveLocal(gameObject:GameObject, to:Vector3[], time:float, optional:Hashtable):int{
	if(to.Length&lt;4){
		var errorMsg:String = &quot;LeanTween - When passing values for a vector path, you must pass four or more values!&quot;;
		if(throwErrors) Debug.LogError(errorMsg); else Debug.Log(errorMsg);
		return -1;
	}
	if(to.Length%4!=0){
		var errorMsg2:String = &quot;LeanTween - When passing values for a vector path, they must be in sets of four: controlPoint1, controlPoint2, endPoint2, controlPoint2, controlPoint2...&quot;;
		if(throwErrors) Debug.LogError(errorMsg2); else Debug.Log(errorMsg2);
		return -1;
	}

	init();
	if( optional == null )
		optional = new Hashtable();

	var ltPath:LTBezierPath = new LTBezierPath( to );
	if(optional[&quot;orientToPath&quot;])
		ltPath.orientToPath = true;
	optional[&quot;path&quot;] = ltPath;

	return pushNewTween( gameObject, Vector3(1.0,0.0,0.0), time, TweenAction.MOVE_CURVED_LOCAL, optional );
}
public static function moveLocal(gameObject:GameObject, to:Vector3[], time:float, optional:Object[]):int{
	return moveLocal( gameObject, to, time, LeanTween.h( optional ) );
}


&#x2F;**
* Move a GUI Element to a certain location
* 
* @method LeanTween.move (GUI)
* @param {LTRect} ltRect:LTRect LTRect object that you wish to move
* @param {Vector2} to:Vector2 The final position with which to move to (pixel coordinates)
* @param {float} time:float The time to complete the tween in
* @param {Hashtable} optional:Hashtable Hashtable where you can pass &lt;a href=&quot;#optional&quot;&gt;optional items&lt;&#x2F;a&gt;.
* @return {int} Returns an integer id that is used to distinguish this tween
*&#x2F;
public static function move(ltRect:LTRect, to:Vector2, time:float, optional:Hashtable):int{
	init();
	if( optional==null || optional.Count == 0 )
		optional = new Hashtable();

	optional[&quot;rect&quot;] = ltRect;
	return pushNewTween( tweenEmpty, to, time, TweenAction.GUI_MOVE, optional );
}

public static function move(ltRect:LTRect, to:Vector2, time:float, optional:Object[]):int{
	return move( ltRect, to, time, h(optional) );
}

&#x2F;**
* Move a GUI Element to a certain location
* 
* @method LeanTween.move (GUI)
* @param {LTRect} ltRect:LTRect LTRect object that you wish to move
* @param {Vector2} to:Vector2 The final position with which to move to (pixel coordinates)
* @param {float} time:float The time to complete the tween in
* @return {int} Returns an integer id that is used to distinguish this tween
*&#x2F;
public static function move(ltRect:LTRect, to:Vector2, time:float):int{
	return move( ltRect, to, time, emptyHash );
}

public static function moveLocal(gameObject:GameObject, to:Vector3, time:float):int{
	return moveLocal( gameObject, to, time, emptyHash );
}

&#x2F;**
* Move a GameObject to a certain location relative to the parent transform. 
* 
* @method LeanTween.moveLocal
* @param {GameObject} gameObject:GameObject Gameobject that you wish to rotate
* @param {Vector3} to:Vector3 The final positin with which to move to
* @param {float} time:float The time to complete the tween in
* @param {Hashtable} optional:Hashtable Hashtable where you can pass &lt;a href=&quot;#optional&quot;&gt;optional items&lt;&#x2F;a&gt;.
* @return {int} Returns an integer id that is used to distinguish this tween
*&#x2F;
public static function moveLocal(gameObject:GameObject, to:Vector3, time:float, optional:Hashtable):int{
	return pushNewTween( gameObject, to, time, TweenAction.MOVE_LOCAL, optional );
}
public static function moveLocal(gameObject:GameObject, to:Vector3, time:float, optional:Object[]):int{
	return moveLocal( gameObject, to, time, h(optional) );
}

public static function moveLocalX(gameObject:GameObject, to:float, time:float, optional:Hashtable):int{
	return pushNewTween( gameObject, Vector3(to,0,0), time, TweenAction.MOVE_LOCAL_X, optional );
}
public static function moveLocalX(gameObject:GameObject, to:float, time:float, optional:Object[]):int{
	return moveLocalX( gameObject, to, time, h(optional) );
}
public static function moveLocalX(gameObject:GameObject, to:float, time:float):int{
	return moveLocalX( gameObject, to, time, emptyHash );
}

public static function moveLocalY(gameObject:GameObject, to:float, time:float, optional:Hashtable):int{
	return pushNewTween( gameObject, Vector3(to,0,0), time, TweenAction.MOVE_LOCAL_Y, optional );
}
public static function moveLocalY(gameObject:GameObject, to:float, time:float, optional:Object[]):int{
	return moveLocalY( gameObject, to, time, h(optional) );
}
public static function moveLocalY(gameObject:GameObject, to:float, time:float):int{
	return moveLocalY( gameObject, to, time, emptyHash );
}

public static function moveLocalZ(gameObject:GameObject, to:float, time:float, optional:Hashtable):int{
	return pushNewTween( gameObject, Vector3(to,0,0), time, TweenAction.MOVE_LOCAL_Z, optional );
}
public static function moveLocalZ(gameObject:GameObject, to:float, time:float, optional:Object[]):int{
	return moveLocalZ( gameObject, to, time, h(optional) );
}
public static function moveLocalZ(gameObject:GameObject, to:float, time:float):int{
	return moveLocalZ( gameObject, to, time, emptyHash );
}


&#x2F;**
* Scale a GameObject to a certain size
* 
* @method LeanTween.scale
* @param {GameObject} gameObject:GameObject Gameobject that you wish to rotate
* @param {Vector3} to:Vector3 The size with which to tween to
* @param {float} time:float The time to complete the tween in
* @param {Hashtable} optional:Hashtable Hashtable where you can pass &lt;a href=&quot;#optional&quot;&gt;optional items&lt;&#x2F;a&gt;.
* @return {int} Returns an integer id that is used to distinguish this tween
*&#x2F;
public static function scale(gameObject:GameObject, to:Vector3, time:float, optional:Hashtable):int{
	return pushNewTween( gameObject, to, time, TweenAction.SCALE, optional );
}
public static function scale(gameObject:GameObject, to:Vector3, time:float, optional:Object[]):int{
	return scale( gameObject, to, time, h(optional) );
}
public static function scale(gameObject:GameObject, to:Vector3, time:float):int{
	return scale( gameObject, to, time, emptyHash );
}

&#x2F;**
* Scale a GUI Element to a certain width and height
* 
* @method LeanTween.scale (GUI)
* @param {LTRect} ltRect:LTRect LTRect object that you wish to move
* @param {Vector2} to:Vector2 The final width and height to scale to (pixel based)
* @param {float} time:float The time to complete the tween in
* @param {Hashtable} optional:Hashtable Hashtable where you can pass &lt;a href=&quot;#optional&quot;&gt;optional items&lt;&#x2F;a&gt;.
* @return {int} Returns an integer id that is used to distinguish this tween
*&#x2F;
public static function scale(ltRect:LTRect, to:Vector2, time:float, optional:Hashtable):int{
	init();
	if( optional==null || optional.Count == 0 )
		optional = new Hashtable();

	optional[&quot;rect&quot;] = ltRect;
	return pushNewTween( tweenEmpty, to, time, TweenAction.GUI_SCALE, optional );
}

public static function scale(ltRect:LTRect, to:Vector2, time:float, optional:Object[]):int{
	return scale( ltRect, to, time, h(optional) );
}

&#x2F;**
* Scale a GUI Element to a certain width and height
* 
* @method LeanTween.scale (GUI)
* @param {LTRect} ltRect:LTRect LTRect object that you wish to move
* @param {Vector2} to:Vector2 The final width and height to scale to (pixel based)
* @param {float} time:float The time to complete the tween in
* @return {int} Returns an integer id that is used to distinguish this tween
* @example
* &lt;i&gt;Example Javascript: &lt;&#x2F;i&gt;&lt;br&gt;
* var bRect:LTRect = new LTRect( 0, 0, 100, 50 );&lt;br&gt;
* LeanTween.scale( bRect, Vector2(bRect.rect.width, bRect.rect.height) * 1.3, 0.25 );&lt;br&gt;
* function OnGUI(){&lt;br&gt;
* &amp;nbsp; if(GUI.Button(bRect.rect, &quot;Scale&quot;)){ }&lt;br&gt;
* }&lt;br&gt;
* &lt;br&gt;
* &lt;i&gt;Example C#: &lt;&#x2F;ia&gt; &lt;br&gt;
* LTRect bRect = new LTRect( 0f, 0f, 100f, 50f );&lt;br&gt;
* LeanTween.scale( bRect, new Vector2(150f,75f), 0.25f );&lt;br&gt;
* void OnGUI(){&lt;br&gt;
* &amp;nbsp; if(GUI.Button(bRect.rect, &quot;Scale&quot;)){ }&lt;br&gt;
* }&lt;br&gt;
*&#x2F;
public static function scale(ltRect:LTRect, to:Vector2, time:float):int{
	return scale( ltRect, to, time, emptyHash );
}

public static function alpha(ltRect:LTRect, to:float, time:float, optional:Hashtable):int{
	init();
	if( optional==null || optional.Count == 0 )
		optional = new Hashtable();

	ltRect.alphaEnabled = true;
	optional[&quot;rect&quot;] = ltRect;
	return pushNewTween( tweenEmpty, Vector3(to,0,0), time, TweenAction.GUI_ALPHA, optional );
}
public static function alpha(ltRect:LTRect, to:float, time:float, optional:Object[]):int{
	return alpha( ltRect, to, time, h(optional) );
}

public static function scaleX(gameObject:GameObject, to:float, time:float):int{
	return scaleX( gameObject, to, time, emptyHash );
}
public static function scaleX(gameObject:GameObject, to:float, time:float, optional:Hashtable):int{
	return pushNewTween( gameObject, Vector3(to,0,0), time, TweenAction.SCALE_X, optional );
}
public static function scaleX(gameObject:GameObject, to:float, time:float, optional:Object[]):int{
	return scaleX( gameObject, to, time, h(optional) );
}

public static function scaleY(gameObject:GameObject, to:float, time:float):int{
	return scaleY( gameObject, to, time, emptyHash );
}
public static function scaleY(gameObject:GameObject, to:float, time:float, optional:Hashtable):int{
	return pushNewTween( gameObject, Vector3(to,0,0), time, TweenAction.SCALE_Y, optional );
}
public static function scaleY(gameObject:GameObject, to:float, time:float, optional:Object[]):int{
	return scaleY( gameObject, to, time, h(optional) );
}

public static function scaleZ(gameObject:GameObject, to:float, time:float):int{
	return scaleZ( gameObject, to, time, emptyHash );
}
public static function scaleZ(gameObject:GameObject, to:float, time:float, optional:Hashtable):int{
	return pushNewTween( gameObject, Vector3(to,0,0), time, TweenAction.SCALE_Z, optional );
}
public static function scaleZ(gameObject:GameObject, to:float, time:float, optional:Object[]):int{
	return scaleZ( gameObject, to, time, h(optional) );
}

&#x2F;**
* Call a function after a certain amount of time has passed
* 
* @method LeanTween.delayedCall
* @param {float} delayTime:float The time with which to delay before calling the function
* @param {Function} callback:Function Function that is called after the certain amount of time.
* @return {int} Returns an integer id that is used to distinguish this tween
*&#x2F;
public static function delayedCall( delayTime:float, callback:Function):int{
	return delayedCall( tweenEmpty, delayTime, callback, new Hashtable() );
}

public static function delayedCall( delayTime:float, callback:Function, optional:Hashtable ):int{
	return delayedCall( tweenEmpty, delayTime, callback, optional );
}
public static function delayedCall( delayTime:float, callback:Function, optional:Object[] ):int{
	return delayedCall( tweenEmpty, delayTime, callback, h(optional) );
}

&#x2F;**
* Call a function after a certain amount of time has passed
* 
* @method LeanTween.delayedCall
* @param {GameObject} gameObject:GameObject Gameobject that you wish to tie this delayed function call to
* @param {float} delayTime:float The time with which to delay before calling the function
* @param {Function} callback:Function Function that is called after the certain amount of time.
* @return {int} Returns an integer id that is used to distinguish this tween
*&#x2F;
public static function delayedCall( gameObject:GameObject, delayTime:float, callback:Function ):int{
	return delayedCall( gameObject, delayTime, callback, new Hashtable() );
}

&#x2F;**
* Call a function after a certain amount of time has passed
* 
* @method LeanTween.delayedCall
* @param {GameObject} gameObject:GameObject Gameobject that you wish to tie this delayed function call to
* @param {float} delayTime:float The time with which to delay before calling the function
* @param {Function} callback:Function Function that is called after the certain amount of time.
* @param {Hashtable} optional:Hashtable Hashtable where you can pass &lt;a href=&quot;#optional&quot;&gt;optional items&lt;&#x2F;a&gt;.
* @return {int} Returns an integer id that is used to distinguish this tween
*&#x2F;
public static function delayedCall( gameObject:GameObject, delayTime:float, callback:Function, optional:Hashtable ):int{
	if(optional==null || optional.Count == 0)
		optional = new Hashtable();
		
	optional[&quot;onComplete&quot;] = callback;
	return pushNewTween( gameObject, Vector3.zero, delayTime, TweenAction.CALLBACK, optional );
}

&#x2F;**
* Call a function after a certain amount of time has passed
* 
* @method LeanTween.delayedCall
* @param {GameObject} gameObject:GameObject Gameobject that you wish to call the Function on
* @param {float} delayTime:float The time with which to delay before calling the function
* @param {String} callback:String Function that is called after the certain amount of time.
* @return {int} Returns an integer id that is used to distinguish this tween
*&#x2F;
public static function delayedCall( gameObject:GameObject, delayTime:float, callback:String):int{
	return delayedCall( gameObject, delayTime, callback, new Hashtable() );
}
&#x2F;**
* Call a function after a certain amount of time has passed
* 
* @method LeanTween.delayedCall
* @param {GameObject} gameObject:GameObject Gameobject that you wish to call the Function on
* @param {float} delayTime:float The time with which to delay before calling the function
* @param {String} callback:String Function that is called after the certain amount of time.
* @param {Hashtable} optional:Hashtable Hashtable where you can pass &lt;a href=&quot;#optional&quot;&gt;optional items&lt;&#x2F;a&gt;.
* @return {int} Returns an integer id that is used to distinguish this tween
*&#x2F;
public static function delayedCall( gameObject:GameObject, delayTime:float, callback:String, optional:Hashtable):int{
	if(optional==null || optional.Count == 0)
		optional = new Hashtable();
	optional[&quot;onComplete&quot;] = callback;

	return pushNewTween( gameObject, Vector3.zero, delayTime, TweenAction.CALLBACK, optional );
}

public static function delayedCall( gameObject:GameObject, delayTime:float, callback:String, optional:Object[]):int{
	return delayedCall( gameObject, delayTime, callback, h(optional) );
}

&#x2F;**
* Fade a gameobject&#x27;s material to a certain alpha value. The material&#x27;s shader needs to support alpha. &lt;a href=&quot;http:&#x2F;&#x2F;owlchemylabs.com&#x2F;content&#x2F;&quot;&gt;Owl labs has some excellent efficient shaders&lt;&#x2F;a&gt;.
* 
* @method LeanTween.alpha
* @param {GameObject} gameObject:GameObject Gameobject that you wish to rotate
* @param {float} to:float The time with which to delay before callin the function
* @param {float} time:float The time with which to delay before calling the function
* @param {Hashtable} optional:Hashtable Hashtable where you can pass &lt;a href=&quot;#optional&quot;&gt;optional items&lt;&#x2F;a&gt;.
* @return {int} Returns an integer id that is used to distinguish this tween
*&#x2F;
public static function alpha(gameObject:GameObject, to:float, time:float, optional:Hashtable):int{
	return pushNewTween( gameObject, Vector3(to,0,0), time, TweenAction.ALPHA, optional );
}

public static function alpha(gameObject:GameObject, to:float, time:float, optional:Object[]):int{
	return alpha(gameObject, to, time, h(optional)); 
}

public static function alpha(gameObject:GameObject, to:float, time:float):int{ 
	return alpha(gameObject, to, time, emptyHash); 
}

&#x2F;**
* This works by tweening the vertex colors directly.&lt;br&gt;
&lt;br&gt;
Vertex-based coloring is useful because you avoid making a copy of your
object&#x27;s material for each instance that needs a different color.&lt;br&gt;
&lt;br&gt;
A shader that supports vertex colors is required for it to work
(for example the shaders in Mobile&#x2F;Particles&#x2F;)
* 
* @method LeanTween.alphaVertex
* @param {GameObject} gameObject:GameObject Gameobject that you wish to alpha
* @param {float} to:float The alpha value you wish to tween to
* @param {float} time:float The time with which to delay before calling the function
* @param {Hashtable} optional:Hashtable Hashtable where you can pass &lt;a href=&quot;#optional&quot;&gt;optional items&lt;&#x2F;a&gt;.
* @return {int} Returns an integer id that is used to distinguish this tween
*&#x2F;
public static function alphaVertex(gameObject:GameObject, to:float, time:float, optional:Hashtable):int{
	return pushNewTween( gameObject, Vector3(to,0,0), time, TweenAction.ALPHA_VERTEX, optional );
}

public static function alphaVertex(gameObject:GameObject, to:float, time:float):int{
	return alphaVertex(gameObject,to,time,null);
}

&#x2F;&#x2F; Tweening Functions - Thanks to Robert Penner and GFX47

private static function tweenOnCurve( LeanTweenDescr:LeanTweenDescr, ratioPassed:float ):float{
	return LeanTweenDescr.from.x + (LeanTweenDescr.to.x - LeanTweenDescr.from.x) * LeanTweenDescr.animationCurve.Evaluate(ratioPassed);
}

private static function tweenOnCurveVector( LeanTweenDescr:LeanTweenDescr, ratioPassed:float ):Vector3{
	return	new Vector3(LeanTweenDescr.from.x + (LeanTweenDescr.to.x-LeanTweenDescr.from.x) * LeanTweenDescr.animationCurve.Evaluate(ratioPassed),
						LeanTweenDescr.from.y + (LeanTweenDescr.to.y-LeanTweenDescr.from.y) * LeanTweenDescr.animationCurve.Evaluate(ratioPassed),
						LeanTweenDescr.from.z + (LeanTweenDescr.to.z-LeanTweenDescr.from.z) * LeanTweenDescr.animationCurve.Evaluate(ratioPassed) );
}

public static function easeOutQuadOpt( start:float, diff:float, ratioPassed:float ):float{
	return -diff * ratioPassed * (ratioPassed - 2) + start;
}

public static function easeInQuadOpt( start:float, diff:float, ratioPassed:float ):float{
	return diff * ratioPassed * ratioPassed + start;
}

public static function easeInOutQuadOpt( start:float, diff:float, ratioPassed:float ):float{
	ratioPassed &#x2F;= .5f;
	if (ratioPassed &lt; 1) return diff &#x2F; 2 * ratioPassed * ratioPassed + start;
	ratioPassed--;
	return -diff &#x2F; 2 * (ratioPassed * (ratioPassed - 2) - 1) + start;
}

public static function linear(start:float, end:float, val:float):float{
	return Mathf.Lerp(start, end, val);
}

public static function clerp(start:float, end:float, val:float):float{
	var min:float = 0.0f;
	var max:float = 360.0f;
	var half:float = Mathf.Abs((max - min) &#x2F; 2.0f);
	var retval:float = 0.0f;
	var diff:float = 0.0f;
	if ((end - start) &lt; -half){
		diff = ((max - start) + end) * val;
		retval = start + diff;
	}else if ((end - start) &gt; half){
		diff = -((max - end) + start) * val;
		retval = start + diff;
	}else retval = start + (end - start) * val;
	return retval;
}

public static function spring(start:float, end:float, val:float):float{
	val = Mathf.Clamp01(val);
	val = (Mathf.Sin(val * Mathf.PI * (0.2f + 2.5f * val * val * val)) * Mathf.Pow(1f - val, 2.2f) + val) * (1f + (1.2f * (1f - val)));
	return start + (end - start) * val;
}

public static function easeInQuad(start:float, end:float, val:float):float{
	end -= start;
	return end * val * val + start;
}

public static function easeOutQuad(start:float, end:float, val:float):float{
	end -= start;
	return -end * val * (val - 2) + start;
}

public static function easeInOutQuad(start:float, end:float, val:float):float{
	val &#x2F;= .5f;
	end -= start;
	if (val &lt; 1) return end &#x2F; 2 * val * val + start;
	val--;
	return -end &#x2F; 2 * (val * (val - 2) - 1) + start;
}

public static function easeInCubic(start:float, end:float, val:float):float{
	end -= start;
	return end * val * val * val + start;
}

public static function easeOutCubic(start:float, end:float, val:float):float{
	val--;
	end -= start;
	return end * (val * val * val + 1) + start;
}

public static function easeInOutCubic(start:float, end:float, val:float):float{
	val &#x2F;= .5f;
	end -= start;
	if (val &lt; 1) return end &#x2F; 2 * val * val * val + start;
	val -= 2;
	return end &#x2F; 2 * (val * val * val + 2) + start;
}

public static function easeInQuart(start:float, end:float, val:float):float{
	end -= start;
	return end * val * val * val * val + start;
}

public static function easeOutQuart(start:float, end:float, val:float):float{
	val--;
	end -= start;
	return -end * (val * val * val * val - 1) + start;
}

public static function easeInOutQuart(start:float, end:float, val:float):float{
	val &#x2F;= .5f;
	end -= start;
	if (val &lt; 1) return end &#x2F; 2 * val * val * val * val + start;
	val -= 2;
	return -end &#x2F; 2 * (val * val * val * val - 2) + start;
}

public static function easeInQuint(start:float, end:float, val:float):float{
	end -= start;
	return end * val * val * val * val * val + start;
}

public static function easeOutQuint(start:float, end:float, val:float):float{
	val--;
	end -= start;
	return end * (val * val * val * val * val + 1) + start;
}

public static function easeInOutQuint(start:float, end:float, val:float):float{
	val &#x2F;= .5f;
	end -= start;
	if (val &lt; 1) return end &#x2F; 2 * val * val * val * val * val + start;
	val -= 2;
	return end &#x2F; 2 * (val * val * val * val * val + 2) + start;
}

public static function easeInSine(start:float, end:float, val:float):float{
	end -= start;
	return -end * Mathf.Cos(val &#x2F; 1 * (Mathf.PI &#x2F; 2)) + end + start;
}

public static function easeOutSine(start:float, end:float, val:float):float{
	end -= start;
	return end * Mathf.Sin(val &#x2F; 1 * (Mathf.PI &#x2F; 2)) + start;
}

public static function easeInOutSine(start:float, end:float, val:float):float{
	end -= start;
	return -end &#x2F; 2 * (Mathf.Cos(Mathf.PI * val &#x2F; 1) - 1) + start;
}

public static function easeInExpo(start:float, end:float, val:float):float{
	end -= start;
	return end * Mathf.Pow(2, 10 * (val &#x2F; 1 - 1)) + start;
}

public static function easeOutExpo(start:float, end:float, val:float):float{
	end -= start;
	return end * (-Mathf.Pow(2, -10 * val &#x2F; 1) + 1) + start;
}

public static function easeInOutExpo(start:float, end:float, val:float):float{
	val &#x2F;= .5f;
	end -= start;
	if (val &lt; 1) return end &#x2F; 2 * Mathf.Pow(2, 10 * (val - 1)) + start;
	val--;
	return end &#x2F; 2 * (-Mathf.Pow(2, -10 * val) + 2) + start;
}

public static function easeInCirc(start:float, end:float, val:float):float{
	end -= start;
	return -end * (Mathf.Sqrt(1 - val * val) - 1) + start;
}

public static function easeOutCirc(start:float, end:float, val:float):float{
	val--;
	end -= start;
	return end * Mathf.Sqrt(1 - val * val) + start;
}

public static function easeInOutCirc(start:float, end:float, val:float):float{
	val &#x2F;= .5f;
	end -= start;
	if (val &lt; 1) return -end &#x2F; 2 * (Mathf.Sqrt(1 - val * val) - 1) + start;
	val -= 2;
	return end &#x2F; 2 * (Mathf.Sqrt(1 - val * val) + 1) + start;
}

&#x2F;* GFX47 MOD START *&#x2F;
public static function easeInBounce(start:float, end:float, val:float):float{
	end -= start;
	var d:float = 1f;
	return end - easeOutBounce(0, end, d-val) + start;
}
&#x2F;* GFX47 MOD END *&#x2F;

&#x2F;* GFX47 MOD START *&#x2F;
&#x2F;&#x2F;public static function bounce(start:float, end:float, val:float):float{
public static function easeOutBounce(start:float, end:float, val:float):float{
	val &#x2F;= 1f;
	end -= start;
	if (val &lt; (1 &#x2F; 2.75f)){
		return end * (7.5625f * val * val) + start;
	}else if (val &lt; (2 &#x2F; 2.75f)){
		val -= (1.5f &#x2F; 2.75f);
		return end * (7.5625f * (val) * val + .75f) + start;
	}else if (val &lt; (2.5 &#x2F; 2.75)){
		val -= (2.25f &#x2F; 2.75f);
		return end * (7.5625f * (val) * val + .9375f) + start;
	}else{
		val -= (2.625f &#x2F; 2.75f);
		return end * (7.5625f * (val) * val + .984375f) + start;
	}
}
&#x2F;* GFX47 MOD END *&#x2F;

&#x2F;* GFX47 MOD START *&#x2F;
public static function easeInOutBounce(start:float, end:float, val:float):float{
	end -= start;
	var d:float = 1f;
	if (val &lt; d&#x2F;2) return easeInBounce(0, end, val*2) * 0.5f + start;
	else return easeOutBounce(0, end, val*2-d) * 0.5f + end*0.5f + start;
}
&#x2F;* GFX47 MOD END *&#x2F;

public static function easeInBack(start:float, end:float, val:float):float{
	end -= start;
	val &#x2F;= 1;
	var s:float = 1.70158f;
	return end * (val) * val * ((s + 1) * val - s) + start;
}

public static function easeOutBack(start:float, end:float, val:float):float{
	var s:float = 1.70158f;
	end -= start;
	val = (val &#x2F; 1) - 1;
	return end * ((val) * val * ((s + 1) * val + s) + 1) + start;
}

public static function easeInOutBack(start:float, end:float, val:float):float{
	var s:float = 1.70158f;
	end -= start;
	val &#x2F;= .5f;
	if ((val) &lt; 1){
		s *= (1.525f);
		return end &#x2F; 2 * (val * val * (((s) + 1) * val - s)) + start;
	}
	val -= 2;
	s *= (1.525f);
	return end &#x2F; 2 * ((val) * val * (((s) + 1) * val + s) + 2) + start;
}

&#x2F;* GFX47 MOD START *&#x2F;
public static function easeInElastic(start:float, end:float, val:float):float{
	end -= start;
	
	var d:float = 1f;
	var p:float = d * .3f;
	var s:float = 0;
	var a:float = 0;
	
	if (val == 0) return start;
	val = val&#x2F;d;
	if (val == 1) return start + end;
	
	if (a == 0f || a &lt; Mathf.Abs(end)){
		a = end;
		s = p &#x2F; 4;
		}else{
		s = p &#x2F; (2 * Mathf.PI) * Mathf.Asin(end &#x2F; a);
	}
	val = val-1;
	return -(a * Mathf.Pow(2, 10 * val) * Mathf.Sin((val * d - s) * (2 * Mathf.PI) &#x2F; p)) + start;
}		
&#x2F;* GFX47 MOD END *&#x2F;

&#x2F;* GFX47 MOD START *&#x2F;
&#x2F;&#x2F;public static function elastic(start:float, end:float, val:float):float{
public static function easeOutElastic(start:float, end:float, val:float):float{
&#x2F;* GFX47 MOD END *&#x2F;
	&#x2F;&#x2F;Thank you to rafael.marteleto for fixing this as a port over from Pedro&#x27;s UnityTween
	end -= start;
	
	var d:float = 1f;
	var p:float = d * .3f;
	var s:float = 0;
	var a:float = 0;
	
	if (val == 0) return start;
	
	val = val &#x2F; d;
	if (val == 1) return start + end;
	
	if (a == 0f || a &lt; Mathf.Abs(end)){
		a = end;
		s = p &#x2F; 4;
		}else{
		s = p &#x2F; (2 * Mathf.PI) * Mathf.Asin(end &#x2F; a);
	}
	
	return (a * Mathf.Pow(2, -10 * val) * Mathf.Sin((val * d - s) * (2 * Mathf.PI) &#x2F; p) + end + start);
}		

&#x2F;* GFX47 MOD START *&#x2F;
public static function easeInOutElastic(start:float, end:float, val:float):float{
	end -= start;
	
	var d:float = 1f;
	var p:float = d * .3f;
	var s:float = 0;
	var a:float = 0;
	
	if (val == 0) return start;
	
	val = val &#x2F; (d&#x2F;2);
	if (val == 2) return start + end;
	
	if (a == 0f || a &lt; Mathf.Abs(end)){
		a = end;
		s = p &#x2F; 4;
		}else{
		s = p &#x2F; (2 * Mathf.PI) * Mathf.Asin(end &#x2F; a);
	}
	
	if (val &lt; 1){
	 val = val-1;
	 return -0.5f * (a * Mathf.Pow(2, 10 * val) * Mathf.Sin((val * d - s) * (2 * Mathf.PI) &#x2F; p)) + start;
	}
	val = val-1;
	return a * Mathf.Pow(2, -10 * val) * Mathf.Sin((val * d - s) * (2 * Mathf.PI) &#x2F; p) * 0.5f + end + start;
}

private static var eventListeners:System.Action.&lt;LTEvent&gt;[,];
private static var goListeners:GameObject[,];
private static var eventsMaxSearch:int = 0;
public static var EVENTS_MAX:int = 10;
public static var LISTENERS_MAX:int = 10;

public static function addListener( event:int, callback:System.Action.&lt;LTEvent&gt; ){
	addListener(tweenEmpty, event, callback);
}

public static function addListener( caller:GameObject, event:int, callback:System.Action.&lt;LTEvent&gt; ){
	if(eventListeners==null){
		eventListeners = new System.Action.&lt;LTEvent&gt;[ EVENTS_MAX, LISTENERS_MAX ];
		goListeners = new GameObject[ EVENTS_MAX, LISTENERS_MAX ];
	}
	&#x2F;&#x2F; Debug.Log(&quot;searching for an empty space for:&quot;+caller);
	for(i = 0; i &lt; LISTENERS_MAX; i++){
		if(goListeners[ event, i]==null || eventListeners[ event, i ] == null){
			eventListeners[ event, i ] = callback;
			goListeners[ event, i] = caller;
			if(i&gt;=eventsMaxSearch)
				eventsMaxSearch = i+1;
			&#x2F;&#x2F; Debug.Log(&quot;adding event for:&quot;+caller.name);

			return;
		}
		if(goListeners[ event, i] === caller &amp;&amp; eventListeners[ event, i ] == callback){
			&#x2F;&#x2F; Debug.Log(&quot;This event is already being listened for.&quot;);
			return;
		}
	}
	Debug.LogError(&quot;You ran out of areas to add listeners, consider increasing LISTENERS_MAX, ex: LeanTween.LISTENERS_MAX = &quot;+(LISTENERS_MAX*2));
}

public static function removeListener( event:int, callback:System.Action ):boolean{
	return removeListener( tweenEmpty, event, callback);
}

public static function removeListener( caller:GameObject, event:int, callback:System.Action.&lt;LTEvent&gt; ):boolean{
	for(i = 0; i &lt; eventsMaxSearch; i++){
		if(goListeners[ event, i] === caller &amp;&amp; eventListeners[ event, i ] == callback){
			eventListeners[ event, i ] = null;
			goListeners[ event, i] = null;
			return true;
		}
	}
	return false;
}

public static function dispatchEvent( event:int ){
	dispatchEvent( event, null);
}

public static function dispatchEvent( event:int, data:Object ){
	for(k = 0; k &lt; eventsMaxSearch; k++){
		if(eventListeners[ event, k ]){
			if(goListeners[event, k]){
				eventListeners[ event, k ]( LTEvent(event, data) );
			}else{
				eventListeners[ event, k ] = null;
			}
		}
	}
}

}

class LTEvent{
	public var id:int;
	public var data:Object;

	public function LTEvent(id:int, data:Object){
		this.id = id;
		this.data = data;
	}
}

class LTPool{

	private var pool:GameObject[];
	private var prefab:GameObject;
	private static var i:int;

	public static function toggleActive( go:GameObject, isActive:boolean ){
		#if UNITY_3_5
			for(var child:Transform in go.transform){
				child.gameObject.active = isActive;
			}
			go.active = isActive;
		#else
			go.SetActiveRecursively( isActive );
		#endif	
	}

	public function LTPool(prefab:GameObject, size:int){
		this.prefab = prefab;
		pool = new GameObject[ size ];
		for(i = 0; i &lt; pool.Length; i++){
			pool[i] = GameObject.Instantiate( prefab, Vector3.zero, Quaternion.identity);
			toggleActive(pool[i], false);
			&#x2F;&#x2F; LeanTween.delayedCall(pool[i], 0.01, deactivate, {&quot;onCompleteParam&quot;:{&quot;go&quot;:pool[i]}} );
			&#x2F;&#x2F;pool[i].hideFlags = HideFlags.HideInHierarchy;
		}
	}

	public function retrieve( pos:Vector3, rotation:Quaternion ):GameObject{
		for(i = 0; i &lt; pool.Length; i++){
			if(pool[i] &amp;&amp; pool[i].active==false){
				toggleActive(pool[i], true);
				pool[i].transform.position = pos;
				pool[i].transform.rotation = rotation;
				&#x2F;&#x2F;pool[i].hideFlags = 0;
				pool[i].BroadcastMessage(&quot;Start&quot;,null,SendMessageOptions.DontRequireReceiver);
				
				return pool[i];
			}
		}
		
		Debug.LogWarning(&quot;LTPool has run out of pooled items and is instantiating the GameObject instead (consider increasing the pooled amount of GameObjects to avoid this)&quot;);
		return GameObject.Instantiate( prefab, pos, rotation);
	}

	public function destroy( go:GameObject ){
		go.transform.localScale = prefab.transform.localScale;
		go.transform.parent = prefab.transform.parent;
		go.BroadcastMessage(&quot;OnDestroy&quot;,null,SendMessageOptions.DontRequireReceiver);
		toggleActive(go, false);
		go.hideFlags = HideFlags.HideInHierarchy;
	}

}

    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="..&#x2F;assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="..&#x2F;assets/js/yui-prettify.js"></script>
<script src="..&#x2F;assets/../api.js"></script>
<script src="..&#x2F;assets/js/api-filter.js"></script>
<script src="..&#x2F;assets/js/api-list.js"></script>
<script src="..&#x2F;assets/js/api-search.js"></script>
<script src="..&#x2F;assets/js/apidocs.js"></script>
</body>
</html>
